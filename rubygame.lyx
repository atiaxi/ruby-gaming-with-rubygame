#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Ruby Gaming with Rubygame
\end_layout

\begin_layout Author
by Roger Ostrander
\end_layout

\begin_layout Part
Basics
\end_layout

\begin_layout Section
A Very Simple Rubygame Program
\begin_inset CommandInset label
LatexCommand label
name "sec:A-Very-Simple"

\end_inset


\end_layout

\begin_layout Subsection
Bare Bones
\end_layout

\begin_layout Standard
I use the word 'program' up there because this isn't really a game.
 For our first foray into Rubygame, we're just going to write something
 that displays an image on the screen.
\end_layout

\begin_layout Standard
very_first.rb
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout

# Every rubygame program you run is going to require this
\end_layout

\begin_layout Plain Layout

require 'rubygame'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# This is for convenience, so we don't have to go around typing
\end_layout

\begin_layout Plain Layout

# Rubygame:: all the time
\end_layout

\begin_layout Plain Layout

include Rubygame
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# This sets up everything behind the scenes.
  You only have to call it
\end_layout

\begin_layout Plain Layout

# once, at the beginning.
\end_layout

\begin_layout Plain Layout

Rubygame.init()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Now the fun part - creating our game window!
\end_layout

\begin_layout Plain Layout

screen = Screen.new( [640,480] ) # The size of the window we want
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Load a picture
\end_layout

\begin_layout Plain Layout

pic = Surface.load("rubygame.png")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Draw it to the screen
\end_layout

\begin_layout Plain Layout

pic.blit(screen, # Surface to draw on,
\end_layout

\begin_layout Plain Layout

  [0,0])         # and where to draw it
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

# Rubygame needs to know what part of the screen changed in order to re-
\end_layout

\begin_layout Plain Layout

# draw it correctly.
\end_layout

\begin_layout Plain Layout

screen.update(0,0,pic.w, pic.h)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Wait for a bit before exiting
\end_layout

\begin_layout Plain Layout

sleep(5)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Before we exit out altogether, we need to tell Rubygame we're done.
\end_layout

\begin_layout Plain Layout

# This is especially important in fullscreen applications!
\end_layout

\begin_layout Plain Layout

Rubygame.quit()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Running that will display the Rubygame logo in the upper-left corner of
 the window for 5 seconds, and then quit.
\end_layout

\begin_layout Standard
This is pretty much the most bare-bones Rubygame program possible, but every
 Rubygame program operates on the same basic steps:
\end_layout

\begin_layout Enumerate
Require files and initialize Rubygame.
\end_layout

\begin_layout Enumerate
Open a game window
\end_layout

\begin_layout Enumerate
Draw to that window
\end_layout

\begin_layout Enumerate
Process user input
\end_layout

\begin_layout Enumerate
If the game isn't over, go back to step 3.
 Otherwise, shut Rubygame down.
\end_layout

\begin_layout Standard
This bare-bones program demonstrated the first three steps.
 How about the rest?
\end_layout

\begin_layout Subsection
The Game Loop
\end_layout

\begin_layout Standard
A very simple form of processing user input would be to make it so the screen
 sticks around until the user hits a key.
 That turns out to be pretty easy:
\end_layout

\begin_layout Standard
very_first_2.rb
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout

require 'rubygame'
\end_layout

\begin_layout Plain Layout

include Rubygame
\end_layout

\begin_layout Plain Layout

Rubygame.init()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Before we create the screen, we're going to make a list of options
\end_layout

\begin_layout Plain Layout

# we'd like it to have:
\end_layout

\begin_layout Plain Layout

flags = [ HWSURFACE,  # If at all possible, set it up on the video card.
\end_layout

\begin_layout Plain Layout

                      # This is a lot faster than doing it in software.
\end_layout

\begin_layout Plain Layout

	DOUBLEBUF, # If the hardware supports it, enable double buffering
\end_layout

\begin_layout Plain Layout

	FULLSCREEN ] # Use the whole screen!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

screen = Screen.new( [640,480], # The size of the window we want
\end_layout

\begin_layout Plain Layout

  0, # This is the color depth of the screen.
  '0' uses whatever the
\end_layout

\begin_layout Plain Layout

     # default is for the user's screen.
\end_layout

\begin_layout Plain Layout

  flags) # These are the flags we were talking about earlier.
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

pic = Surface.load("rubygame.png")
\end_layout

\begin_layout Plain Layout

# Convert the picture to the default color depth.
  If we don't do this
\end_layout

\begin_layout Plain Layout

# beforehand, it's going to do it anyway right before it draws the
\end_layout

\begin_layout Plain Layout

# image.
  Constant converting like that would slow things down hugely.
\end_layout

\begin_layout Plain Layout

pic = pic.convert()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Everything that happens while the game is running - keys pressed,
\end_layout

\begin_layout Plain Layout

# joysticks moved, mice clicked, etc - comes to us in the form
\end_layout

\begin_layout Plain Layout

# of events.
  We go through them one by one using this queue:
\end_layout

\begin_layout Plain Layout

queue = EventQueue.new()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# A simple flag to indicate we're done.
\end_layout

\begin_layout Plain Layout

finished = false
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# The game loop!
\end_layout

\begin_layout Plain Layout

while not finished
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	# Draw on the screen
\end_layout

\begin_layout Plain Layout

	pic.blit(screen, [0,0])
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	# If the hardware gods were kind to us and we got a hardware surface
\end_layout

\begin_layout Plain Layout

	# with double-buffer support, we can take a shortcut.
  Rather than
\end_layout

\begin_layout Plain Layout

	# tell Rubygame what part of the screen was updated, we can tell it
\end_layout

\begin_layout Plain Layout

	# that the whole screen changed, and to update everything at once:
\end_layout

\begin_layout Plain Layout

	screen.flip()
\end_layout

\begin_layout Plain Layout

	# If we didn't get a hardware surface, this just updates the whole
\end_layout

\begin_layout Plain Layout

	# screen without being fast about it.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	# Process all events that came up this time around.
\end_layout

\begin_layout Plain Layout

	queue.each do | event |
\end_layout

\begin_layout Plain Layout

		case(event)
\end_layout

\begin_layout Plain Layout

		# This event happens whenever someone clicks the 'x' button.
\end_layout

\begin_layout Plain Layout

		# Always respond to this, because it's rude not to.
\end_layout

\begin_layout Plain Layout

		when QuitEvent
\end_layout

\begin_layout Plain Layout

			finished = true
\end_layout

\begin_layout Plain Layout

		# This event happens whenever someone presses a key.
\end_layout

\begin_layout Plain Layout

		when KeyDownEvent
\end_layout

\begin_layout Plain Layout

			# For the purposes of our demo, we're going to quit when this
\end_layout

\begin_layout Plain Layout

			# happens.
\end_layout

\begin_layout Plain Layout

			finished = true
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Rubygame.quit()
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are a number of new concepts:
\end_layout

\begin_layout Subsubsection
Color Depth and Surface Flags
\end_layout

\begin_layout Standard
When I created the screen, this time around, I gave it two extra arguments.
 The first is the 
\series bold
color depth
\series default
 - this indicates how many bits a pixel should take up.
 If you're running this on anything close to a modern computer, this will
 almost always be 32.
 However, you can't count on that always being the case.
 That's why it's a good practice to put '0' in there.
 That will allow the computer to use whatever color depth is the default
 for it.
 
\end_layout

\begin_layout Standard
The second argument was a list of flags.
 These 
\series bold
surface flags
\series default
 are extra information used when setting up the screen.
 We asked for a hardware surface, meaning all our drawing will be done directly
 on the video card.
 We also asked for double buffering support (more on this later) and for
 our display to be full screen.
 Keep in mind that these flags are all requests - depending on the underlying
 hardware support, you may not get everything you ask for.
\end_layout

\begin_layout Subsubsection
Converting Surfaces
\end_layout

\begin_layout Standard
By default, whenever you load something using Surface.load, it's going to
 be in whatever color depth it was on disk.
 So if you load in an 8-bit image, Rubygame is going to have to convert
 it to whatever you're using (likely 32 bits) every time it draws it on
 the screen.
 We explicitly convert it to save a lot of time and effort.
\end_layout

\begin_layout Subsubsection
The Event Queue
\end_layout

\begin_layout Standard
Some game frameworks use polling; with them, if you wanted to know if the
 user was pressing a key, you'd have to constantly call the function that
 asks if a key is being pressed.
 Rubygame works via events - you'll be notified when a key is pressed, and
 then you can check if it's the one you want.
 All these events are put in the queue that we create.
\end_layout

\begin_layout Subsubsection
Double Buffering
\end_layout

\begin_layout Standard
Even if you draw something to the screen, this work is done in a 
\begin_inset Quotes eld
\end_inset

Back Buffer
\begin_inset Quotes erd
\end_inset

 - an area in memory that exists so you can prepare all your changes at
 once.
 The update() call in the first example says 
\begin_inset Quotes eld
\end_inset

This part of the back buffer is ready to be drawn
\begin_inset Quotes erd
\end_inset

.
 If it's done right, just calling update() with the right rectangles can
 be faster than updating the entire screen, but keep in mind that the more
 time you spend tracking what parts of the screen need to be redrawn, the
 less time you're saving.
\end_layout

\begin_layout Standard
Double Buffering simply allows the back buffer and screen to flip places.
 What this means to you is that the entire screen is updated at once and,
 if your hardware supports it, it's done quickly.
 The 'flip' function does all this for you.
 If you didn't end up getting a hardware surface or one that supports double-buf
fering, it falls back on simply updating the entire screen.
\end_layout

\begin_layout Standard
Because it's simple, I'll be using double buffering for the rest of this
 book.
\end_layout

\begin_layout Subsubsection
Event Types
\end_layout

\begin_layout Standard
The first thing we did with our queue was to enable 
\begin_inset Quotes eld
\end_inset

new style
\begin_inset Quotes erd
\end_inset

 events.
 Without this, you'll get entirely different event classes that are deprecated.
 When Rubygame 3 comes out, they'll be gone entirely, so it's a good idea
 to get used to working with the new ones.
 Every event you'll see generated comes from the Rubygame::Events namespace.
\end_layout

\begin_layout Standard
Using a 'case' statement to go through each item in the queue is helpful
 because it'll match on the class of the event, which is likely to determine
 what you do next.
\end_layout

\begin_layout Standard
The 
\series bold
QuitRequested
\series default
 happens when the user indicates they want to quit - they hit the 'x' button,
 or press Alt-F4, or otherwise try to stop the application.
 If you don't respond to this event, your app will keep running.
 This would be the time to do things like quickly save a game or prompt
 for a confirmation, but even then be very careful.
 The user won't appreciate having to kill your program because it doesn't
 appear to be closing right.
\end_layout

\begin_layout Standard
The 
\series bold
KeyDownEvent
\series default
 is exactly what it sounds like: Whenever the user presses a key, this is
 fired.
 Later, we'll use the information in the 'event' variable but for now we
 just quit.
\end_layout

\begin_layout Subsection
Interactivity
\end_layout

\begin_layout Standard
The previous example illustrated a full game loop, but not an interesting
 one.
 Sitting around displaying one image while waiting for the user to press
 a key and then quitting is hardly the pinnacle of game design, after all.
 Let's make it so the user can move the picture around:
\end_layout

\begin_layout Standard
very_first_3.rb
\end_layout

\begin_layout LyX-Code
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout

require 'rubygame'
\end_layout

\begin_layout Plain Layout

include Rubygame
\end_layout

\begin_layout Plain Layout

Rubygame.init()
\end_layout

\begin_layout Plain Layout

# So that we can hold down the button and have it work
\end_layout

\begin_layout Plain Layout

Rubygame.enable_key_repeat(0.5, 0.03)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

flags = [ HWSURFACE, DOUBLEBUF ] 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

screen = Screen.new( [640,480], 0, flags )
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

pic = Surface.load("rubygame.png")
\end_layout

\begin_layout Plain Layout

pic = pic.convert()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

queue = EventQueue.new()
\end_layout

\begin_layout Plain Layout

queue.enable_new_style_events()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

finished = false
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# The location of our picture.
\end_layout

\begin_layout Plain Layout

x = 0
\end_layout

\begin_layout Plain Layout

y = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# How many pixels per second it'll move.
\end_layout

\begin_layout Plain Layout

speed = 100
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# The Clock object helps us move at a constant rate of speed, as we'll
\end_layout

\begin_layout Plain Layout

# see later.
\end_layout

\begin_layout Plain Layout

clock = Clock.new
\end_layout

\begin_layout Plain Layout

# This is also going to become the default in Rubygame 3.0, so we might
\end_layout

\begin_layout Plain Layout

# as well get used to it
\end_layout

\begin_layout Plain Layout

clock.enable_tick_events()
\end_layout

\begin_layout Plain Layout

# The clock lets us enter the amount of FPS we'd like.
  It then slows
\end_layout

\begin_layout Plain Layout

# us down to that number:
\end_layout

\begin_layout Plain Layout

clock.target_framerate = 30
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# The game loop!
\end_layout

\begin_layout Plain Layout

while not finished
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	# This is the number of seconds since last time we were here.
\end_layout

\begin_layout Plain Layout

	# Knowing this number lets us smooth out motion correctly.
\end_layout

\begin_layout Plain Layout

	delay = clock.tick.seconds
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	# Clear the screen first
\end_layout

\begin_layout Plain Layout

	screen.fill( [0,0,0] )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	pic.blit(screen, [x,y])
\end_layout

\begin_layout Plain Layout

	screen.flip()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	queue.each do | event |
\end_layout

\begin_layout Plain Layout

		case(event)
\end_layout

\begin_layout Plain Layout

		when Events::QuitRequested
\end_layout

\begin_layout Plain Layout

			finished = true
\end_layout

\begin_layout Plain Layout

		when Events::KeyPressed
\end_layout

\begin_layout Plain Layout

			# The 'key' field is a symbol
\end_layout

\begin_layout Plain Layout

			if event.key == :up
\end_layout

\begin_layout Plain Layout

				y -= speed * delay
\end_layout

\begin_layout Plain Layout

			elsif event.key == :down
\end_layout

\begin_layout Plain Layout

				y += speed * delay
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

			if event.key == :left
\end_layout

\begin_layout Plain Layout

				x -= speed * delay
\end_layout

\begin_layout Plain Layout

			elsif event.key == :right
\end_layout

\begin_layout Plain Layout

				x += speed * delay
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		when Events::MouseMoved
\end_layout

\begin_layout Plain Layout

			# The 'pos' field is an array of the form [x,y] which
\end_layout

\begin_layout Plain Layout

			# indicates where the mouse event happened.
\end_layout

\begin_layout Plain Layout

			x = event.pos[0]
\end_layout

\begin_layout Plain Layout

			y = event.pos[1]
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Rubygame.quit()
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As before, I've done some new things:
\end_layout

\begin_layout Subsubsection
Key Repeat
\end_layout

\begin_layout Standard
You'll notice that the events we're reacting to when we're moving the image
 around are simple 
\series bold
KeyPressed
\series default
 events.
 We included a line at the very top to enable key repeat.
 That way the user can hold down a button and Rubygame will keep generating
 KeyPressed events for us.
 This isn't the ideal way to handle continuous user input: There's a delay
 between events and so relying on this method will always result in somewhat
 choppy movement.
 I'll show a better way to handle this in section
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Pong"

\end_inset

.
\end_layout

\begin_layout Subsubsection
The Clock
\end_layout

\begin_layout Standard
If you kept an eye on your CPU usage while runing very_first_2.rb, you'll
 probably notice that it spiked enormously.
 It might seem a bit strange that clearing the screen and drawing an image
 should take so much CPU power.
 The fact is, it doesn't, but we didn't introduce any kind of delay or tell
 the operating system we were willing to have it take over for a bit.
 All we did was draw to the screen and look for input in a nonstop tight
 loop.
 It might seem like this is the proper way to work; after all, your game
 will run its fastest if it doesn't bother to wait or put a delay in, but
 keep in mind people aren't going to appreciate having their CPUs entirely
 maxed out running just your game.
\end_layout

\begin_layout Standard
The solution is to put a delay in, and Rubygame offers this in the form
 of the Clock class.
 You tell it how many FPS you'd like to be the maximum, and every time you
 call clock.tick(), it delays so that you meet that FPS goal.
 Obviously it can only do this if you're running faster than the goal.
\end_layout

\begin_layout Standard
The second benefit of the Clock class is that clock.tick returns an object
 that holds the number of seconds since the last time it was called.
 Recall that earlier in the program, we defined the speed of our image in
 pixels per second.
 It'd be hard to actually make it go that speed if we didn't know how many
 seconds had passed!
\end_layout

\begin_layout Subsubsection
Events
\end_layout

\begin_layout Standard
We looked over this briefly in the previous section, but now we're actually
 doing something with our data.
\end_layout

\begin_layout Paragraph
KeyPressed
\end_layout

\begin_layout Standard
We use the 'key' field of this event to determine what to do, and for the
 most part that's what you'll be relying on.
 It's a symbol that corresponds to the key that was pressed.
 So :left is the symbol for the left arrow, :w would be the symbol for the
 'w' key, :f1 is the symbol for F1, and so on.
 For the most part the naming is obvious, but if you want to know the symbol
 for an event there's a fairly simple program that will tell you.
 I've provided it in Appendix 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Key-Symbol-Cheatsheet"

\end_inset

.
\end_layout

\begin_layout Standard
You can tell which modifier keys were held down while the button was pressed
 by looking at the 
\begin_inset Quotes eld
\end_inset

modifiers
\begin_inset Quotes erd
\end_inset

 field, and you can get a printable representation by looking at the contents
 of 
\begin_inset Quotes eld
\end_inset

string
\begin_inset Quotes erd
\end_inset

.
 That way if the user presses shift and 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset

, you don't have to just guess that this is 
\begin_inset Quotes eld
\end_inset

?
\begin_inset Quotes erd
\end_inset

.
 (Especially because that may not be true on other keyboards!)
\end_layout

\begin_layout Paragraph
MouseMoved
\end_layout

\begin_layout Standard
I added this to show a different kind of event.
 MouseMoved tells us that the mouse moved (surprise!).
 We use this to move the image to wherever the mouse currently is.
 The 
\begin_inset Quotes eld
\end_inset

pos
\begin_inset Quotes erd
\end_inset

 field holds the mouse position at the time the event happened.
\end_layout

\begin_layout Subsection
Wrapup
\end_layout

\begin_layout Standard
You officially now have enough knowledge of Rubygame to create a game.
 You can create the screen, draw to it, and respond to user input, and that's
 all you need to know!
\end_layout

\begin_layout Standard
Of course, Rubygame has a great many features which make our life easier.
 The next chapter will have us use everything we just learned as well as
 some new information to create our first full game: That old standby 
\begin_inset Quotes eld
\end_inset

Pong
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Pong
\begin_inset CommandInset label
LatexCommand label
name "sec:Pong"

\end_inset


\end_layout

\begin_layout Standard
Pong was one of the very first video games, dating back to 1972.
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

But,
\begin_inset Quotes erd
\end_inset

 you say, 
\begin_inset Quotes eld
\end_inset

that demo we did in the first section is more sophisticated than that! Why
 are we starting so low-tech?
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
The answer is: Because it's the best way to learn.
 So long as you're doing it for your own learning purposes, re-making old
 games is an excellent way to figure out how things work, because you've
 already got the concept and know how it should turn out.
 All you need to provide is the code and some art, and even programmer art
 ends up better-looking than 1972 Pong!
\end_layout

\begin_layout Subsection
Sprites
\end_layout

\begin_layout Standard
In section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:A-Very-Simple"

\end_inset

's example, we kept track of all the information about our image in variables.
 This works out fine so long as you have a very few images, but what if
 you have more? You don't want to name everything image_1, image_2 or paddle_ima
ge, paddle_x, paddle_y, etc.
 A much easier way to keep track of these things would be in a class:
\end_layout

\begin_layout Standard
simple_class_example.rb
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Paddle
\end_layout

\begin_layout Plain Layout

	attr_accessor :x, :y
\end_layout

\begin_layout Plain Layout

	attr_accessor :speed_x, :speed_y
\end_layout

\begin_layout Plain Layout

	attr_accessor :image
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It turns out that our theoretical Paddle class has a lot in common with
 anything we'd want to draw on the screen - it's got a location and an image,
 for instance.
 We'd probably want to put in a draw() function that paints it to the screen.
 It'd be handy to have a function that'd tell us if it's colliding with
 a ball, as well.
\end_layout

\begin_layout Standard
As it happens, these operations are so common that Rubygame has provided
 a class for them...
 sort of.
 There's a mixin called Rubygame::Sprite that keeps information on where
 a sprite is, as well as how to draw it to the screen.
 You include it in your own objects in order to use its functionality.
 Here's an initial look at the Paddle class using Rubygame::Sprite:
\end_layout

\begin_layout Standard
paddle.rb
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'rubygame'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

include Rubygame
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Paddle
\end_layout

\begin_layout Plain Layout

	include Sprites::Sprite
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	# Sprite already has an 'image' accessor for us, as well
\end_layout

\begin_layout Plain Layout

	# as a 'rect' accessor that determines where the sprite is
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	# It doesn't give us a speed, though, so we're going to have
\end_layout

\begin_layout Plain Layout

	# to provide that ourselves
\end_layout

\begin_layout Plain Layout

	attr_accessor :speed
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def initialize(filename)
\end_layout

\begin_layout Plain Layout

		# If you use the default draw function that the Sprite
\end_layout

\begin_layout Plain Layout

		# mixin provides (and we are in this example), then you
\end_layout

\begin_layout Plain Layout

		# need to have an @image variable
\end_layout

\begin_layout Plain Layout

		@image = Surface.load(filename).convert()
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		# This is a Rubygame Rectangle, and it provides us with all
\end_layout

\begin_layout Plain Layout

		# kinds of useful functionality.
  Like @image, it's required
\end_layout

\begin_layout Plain Layout

		# for the Sprite mixin.
\end_layout

\begin_layout Plain Layout

		@rect = Rect.new(0,0,@image.w, @image.h)
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@speed = 100
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let's see it in action - here's the very beginning of our pong program:
\end_layout

\begin_layout Standard
pong.rb
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'rubygame'
\end_layout

\begin_layout Plain Layout

require 'paddle'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

include Rubygame
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def main()
\end_layout

\begin_layout Plain Layout

	Rubygame.init()
\end_layout

\begin_layout Plain Layout

	flags = [HWSURFACE, DOUBLEBUF]
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	screen = Screen.new( [640,480], 0, flags)
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	clock = Clock.new
\end_layout

\begin_layout Plain Layout

	clock.enable_tick_events()
\end_layout

\begin_layout Plain Layout

	clock.target_framerate = 30
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	queue = EventQueue.new()
\end_layout

\begin_layout Plain Layout

	queue.enable_new_style_events()
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	# Here's where we create our new paddle object, rather
\end_layout

\begin_layout Plain Layout

	# than use a bunch of separate variables for the task
\end_layout

\begin_layout Plain Layout

	paddle = Paddle.new("paddle.png")
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	finished = false
\end_layout

\begin_layout Plain Layout

	while not finished
\end_layout

\begin_layout Plain Layout

		delay = clock.tick.seconds
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		screen.fill( [0, 0, 0] )
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		paddle.draw(screen)
\end_layout

\begin_layout Plain Layout

		screen.flip()
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		queue.each do |event|
\end_layout

\begin_layout Plain Layout

			case(event)
\end_layout

\begin_layout Plain Layout

			when Events::QuitRequested
\end_layout

\begin_layout Plain Layout

				finished = true
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if __FILE__ == $0
\end_layout

\begin_layout Plain Layout

	main()
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If anything, this has less functionality than the previous demo - we've
 gone back to simply displaying an image on the screen.
 A very ugly image, for that matter! But we did cover some important areas
 getting to this point, and it's starting to look less like a simple demo
 and more like a proper game.
 Here's what's new:
\end_layout

\begin_layout Subsubsection
The Sprite Mixin
\end_layout

\begin_layout Standard
As mentioned in the code, including the sprite only requires you do two
 things: First, provide an @image variable with the Surface that will be
 drawn, and second, provide a @rect variable to represent where this image
 is on screen.
 You'll notice that we call Paddle.draw(screen) in the main 'pong.rb' file
 but haven't defined it anywhere - that's because the Sprite mixin has provided
 that code for us.
 It's the same code as we used in the first example (using Surface.blit)
 but since it's already been written for us, let's not reinvent the wheel!
\end_layout

\begin_layout Subsubsection
The Paddle Object
\end_layout

\begin_layout Standard
This isn't exactly a new Rubygame concept, given that we created it ourselves
 up there, but it is an important one.
 Separating our game objects out of the main loop is one step toward a more
 object-oriented approach, and that's one that makes it easier to change
 things later.
 For similar reasons, this is also why we put the Paddle code in its own
 file.
 For now, we're not doing much else in the way of separation, but keep it
 in mind as we go along.
\end_layout

\begin_layout Subsubsection
This is boring!
\end_layout

\begin_layout Standard
That's a good point: Let's put some interactivity into our paddle.
 Add this to the initialize function in the Paddle class in paddle.rb:
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@keys = {}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And then add these functions to the class:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def key(sym, pressed)
\end_layout

\begin_layout Plain Layout

		@keys[sym] = pressed
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def move(dx, dy)
\end_layout

\begin_layout Plain Layout

		@rect.move!(dx,dy)
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		amount = delay * @speed
\end_layout

\begin_layout Plain Layout

		if @keys[:up]
\end_layout

\begin_layout Plain Layout

			move(0,-amount)
\end_layout

\begin_layout Plain Layout

		elsif @keys[:down]
\end_layout

\begin_layout Plain Layout

			move(0, amount)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if @keys[:left]
\end_layout

\begin_layout Plain Layout

			move(-amount, 0)
\end_layout

\begin_layout Plain Layout

		elsif @keys[:right]
\end_layout

\begin_layout Plain Layout

			move(amount, 0)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The update function should look a little familiar - it's very similar to
 the one we used in our first demo.
 Instead of checking event types and then keys, though, we're referring
 to a dictionary of keys.
 This dictionary is in the form of :key => boolean, where :key is the key
 in question, and the boolean is whether it's currently pressed or not.
 We create this dictionary in initialize() and keep it up to date in the
 key() function.
 But if you ran this right now, you'd notice that nothing's happening.
 That's for two reasons: One, the key() function isn't being called.
 Two, even if it was, update() is also not being called! 
\end_layout

\begin_layout Standard
Let's make some changes to pong.rb to fix that.
 Change your queue loop to look like this:
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		queue.each do |event|
\end_layout

\begin_layout Plain Layout

			case(event)
\end_layout

\begin_layout Plain Layout

			when Events::QuitRequested
\end_layout

\begin_layout Plain Layout

				finished = true
\end_layout

\begin_layout Plain Layout

			when Events::KeyPressed
\end_layout

\begin_layout Plain Layout

				paddle.key(event.key, true)
\end_layout

\begin_layout Plain Layout

			when Events::KeyReleased
\end_layout

\begin_layout Plain Layout

				paddle.key(event.key, false)
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		paddle.update(delay)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now if you run that, you'll be able to move the image of the paddle all
 around the screen.
\end_layout

\begin_layout Subsubsection
But what exactly is happening there?
\end_layout

\begin_layout Standard
We're actually doing the same thing we were doing in the first demo, it's
 just somewhat removed from the internals now.
 Here's an outline of what our game loop is like and how it's interacting
 with paddle.rb:
\end_layout

\begin_layout Enumerate
paddle.draw(screen) is called - this calls the sprite mixin that we included
 in paddle.rb, which draws the @image variable to the screen at the @rect
 location.
\end_layout

\begin_layout Enumerate
If we get any key events - either pressed or released - we call the 'key'
 function that sets up a :key => pressed/released relation in a dictionary.
\end_layout

\begin_layout Enumerate
We call update(delay) on our paddle.
 That's when it looks at the dictionary and sees if any of the keys it's
 interested in are pressed.
 If so, it moves the paddle.
\end_layout

\begin_layout Standard
If you've paid very close attention to the differences between this and
 the last demo, you'll notice there was a part of the setup we didn't do:
 We never called enable_key_repeat.
 But if you've ran the above, you've seen that the paddle moves around the
 screen smoothly as long as you hold the button down.
 What gives?
\end_layout

\begin_layout Subsubsection
Smooth Moves
\end_layout

\begin_layout Standard
The first demo moved things by reacting explicitly to the key press and
 nothing else.
 The key press events are (normally) only generated once, when you press
 the key.
 The enable_key_repeat function changes that, by feeding a stream of KeyPressed
 events so long as you're holding the button down.
 As mentioned before, this works for the most part but isn't ideal - it
 can result in somewhat jerky behavior and creates an awful lot of event
 objects.
\end_layout

\begin_layout Standard
We get around that by storing the current state of the key in the paddle.
 Any time we get an event, we update that state, but otherwise we don't
 do any further processing.
 Later, when we call update(delay), we check the current state of the key
 to determine what to do.
 Since we call that update function about 30 times a second and we only
 change the state in response to the user doing something, we end up with
 smooth movement.
\end_layout

\begin_layout Subsubsection
Constraints
\end_layout

\begin_layout Standard
You probably noticed something about the behavior of the paddle, and also
 the rubygame logo from the first demo: You can easily move them off the
 screen.
 Obviously, this is not something we want to allow! Furthermore, it'd be
 a bit like cheating if we left in the player's ability to move horizontally.
 Change paddle.rb's update function to look like this:
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		amount = delay * @speed
\end_layout

\begin_layout Plain Layout

		if @keys[:up]
\end_layout

\begin_layout Plain Layout

			move(0,-amount)
\end_layout

\begin_layout Plain Layout

		elsif @keys[:down]
\end_layout

\begin_layout Plain Layout

			move(0, amount)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		# As long as the screen's been created, you can get it
\end_layout

\begin_layout Plain Layout

		# from anywhere in the program using this
\end_layout

\begin_layout Plain Layout

		screen = Screen.get_surface()
\end_layout

\begin_layout Plain Layout

		if @rect.top < 0
\end_layout

\begin_layout Plain Layout

			@rect.top = 0
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		if @rect.bottom > screen.h
\end_layout

\begin_layout Plain Layout

			@rect.bottom = screen.h
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Rectangle methods
\end_layout

\begin_layout Standard
We haven't done much with the @rect object besides set it up in the first
 place and then move it around.
 It turns out that Rubygame::Rect has a large number of functions that can
 prove very useful.
 You can both get and set the top and bottom (and left and right, for that
 matter), rather than adding the y location to the height and doing the
 math yourself.
\end_layout

\begin_layout Subsubsection
The Screen
\end_layout

\begin_layout Standard
Screen.get_surface() will give you the screen, so long as it's been created,
 anywhere in your program.
 Be careful with it, though, as if you call it before you've actually created
 the screen, it'll error out.
\end_layout

\begin_layout Subsubsection
Okay, so why is the paddle so ugly?
\end_layout

\begin_layout Standard
Because I'm a horrible artist.
\end_layout

\begin_layout Standard
But that's probably not what you're referring to.
 Rather, you're wondering what the garish magenta box outline around the
 paddle is all about.
 It comes down to background colors.
 Because we want a rounded paddle but all images are loaded as squares,
 we've got a portion of the image that's just background.
 Now, you could take the easy way out and change that magenta to black,
 and everything would look fine.
 Later, though, if you wanted to change your background color to something
 else you'd have to go through every image and re-paint its background.
\end_layout

\begin_layout Standard
Imagine that, instead, you could just tell Rubygame that you want a certain
 color to be treated as transparent.
 Now, you could choose black or white but chances are good that those colors
 are going to be in an image eventually.
 Thus, we chose magenta.
 Full red, no green, full blue - it's a horrible eye-catching color that
 will, if we live fortunate lives, never occur in our images naturally.
\end_layout

\begin_layout Standard
So, once we've picked a color, how do we tell Rubygame to use it as a background
? Change your initialize() for the Paddle class to be this:
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def initialize(filename)
\end_layout

\begin_layout Plain Layout

		# If you use the default draw function that the Sprite
\end_layout

\begin_layout Plain Layout

		# mixin provides (and we are in this example), then you
\end_layout

\begin_layout Plain Layout

		# need to have an @image variable
\end_layout

\begin_layout Plain Layout

		@image = Surface.load(filename).convert()
\end_layout

\begin_layout Plain Layout

		@image.colorkey = [255, 0, 255]
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		# This is a Rubygame Rectangle, and it provides us with all
\end_layout

\begin_layout Plain Layout

		# kinds of useful functionality.
  Like @image, it's required
\end_layout

\begin_layout Plain Layout

		# for the Sprite mixin.
\end_layout

\begin_layout Plain Layout

		@rect = Rect.new(0,0,@image.w, @image.h)
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@speed = 100
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		# This will eventually hold the state of the entire keyboard
\end_layout

\begin_layout Plain Layout

		@keys = {}
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The colorkey accessor controls which color (if any) should be treated as
 the background color and not painted.
 You specify the color the same way we did when we cleared the screen, in
 [red,green,blue] and on a scale of 0-255.
 Once that's done, run and see the (slightly) more beautiful paddle.
\end_layout

\begin_layout Subsection
Moving on its own
\end_layout

\begin_layout Standard
Our paddle is more or less in good enough shape.
 Let's make the thing we're supposed to be batting around - the ball:
\end_layout

\begin_layout Standard
ball.rb
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'rubygame'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

include Rubygame
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Ball
\end_layout

\begin_layout Plain Layout

	include Sprites::Sprite
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def initialize(filename)
\end_layout

\begin_layout Plain Layout

		@image = Surface.load(filename).convert()
\end_layout

\begin_layout Plain Layout

		@image.colorkey = [255,0,255]
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@rect = Rect.new(0,0,@image.w, @image.h)
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		reset
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def reset
\end_layout

\begin_layout Plain Layout

		screen = Screen.get_surface()
\end_layout

\begin_layout Plain Layout

		@rect.center = [screen.w/2, screen.h / 2]
\end_layout

\begin_layout Plain Layout

		@direction = [-1.0, -1.0]
\end_layout

\begin_layout Plain Layout

		@speed = 150
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		amount = delay * @speed
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@rect.x += @direction[0] * amount;
\end_layout

\begin_layout Plain Layout

		@rect.y += @direction[1] * amount;
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You'll probably notice that the initialize() routine is almost exactly the
 same as the paddle's.
 In the future we'll be taking advantage of this fact and making our own
 classes to handle it, but for now we'll have to deal with duplicated code.
\end_layout

\begin_layout Standard
What's new?
\end_layout

\begin_layout Subsubsection
Reset
\end_layout

\begin_layout Standard
About half of the initialization is actually done in the reset() function.
 The reason for this is that the function puts the ball back in the middle
 of the screen and sets its initial direction and speed.
 We want that in its own function so we can call it later (such as when
 one of the players scores a point) and not just at the beginning when it's
 created
\end_layout

\begin_layout Subsubsection
Update
\end_layout

\begin_layout Standard
The update should look a little bit familiar - I'm doing the same scaling
 technique I did with the paddle in order to keep it moving at a smooth
 150 pixels per second (or whatever its @speed happens to be at the time).
 After that, though, note that I'm not taking any user input.
 This is intentional - the only influence the player should have over the
 ball is bouncing it against the paddle.
 Instead, its 'x' location is increased by the first part of its direction,
 and its 'y' location is increased by the second part.
 We're keeping the 'direction' as a simple array because all we really want
 to know is:
\end_layout

\begin_layout Description
Is
\begin_inset space ~
\end_inset

it
\begin_inset space ~
\end_inset

traveling
\begin_inset space ~
\end_inset

left
\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset

right? If so, the first item in @direction will be -1 for left or 1 for
 right, and
\end_layout

\begin_layout Description
Is
\begin_inset space ~
\end_inset

it
\begin_inset space ~
\end_inset

traveling
\begin_inset space ~
\end_inset

up
\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset

down? Similarly, the second item in @direction will be -1 for up or 1 for
 down.
\end_layout

\begin_layout Subsubsection
Adding the ball to the field
\end_layout

\begin_layout Standard
Running the game right now will have no effect, because we don't actually
 use our ball object anywhere.
 So open up 'pong.rb' and add the following line to the top after the other
 'require' statements:
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'ball'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then rewrite the game loop as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	paddle = Paddle.new("paddle.png")
\end_layout

\begin_layout Plain Layout

	ball = Ball.new("ball.png")
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	finished = false
\end_layout

\begin_layout Plain Layout

	while not finished
\end_layout

\begin_layout Plain Layout

		delay = clock.tick.seconds
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		screen.fill( [0, 0, 0] )
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		paddle.draw(screen)
\end_layout

\begin_layout Plain Layout

		ball.draw(screen)
\end_layout

\begin_layout Plain Layout

		screen.flip()
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		queue.each do |event|
\end_layout

\begin_layout Plain Layout

			case(event)
\end_layout

\begin_layout Plain Layout

			when Events::QuitRequested
\end_layout

\begin_layout Plain Layout

				finished = true
\end_layout

\begin_layout Plain Layout

			when Events::KeyPressed
\end_layout

\begin_layout Plain Layout

				paddle.key(event.key, true)
\end_layout

\begin_layout Plain Layout

			when Events::KeyReleased
\end_layout

\begin_layout Plain Layout

				paddle.key(event.key, false)
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		paddle.update(delay)
\end_layout

\begin_layout Plain Layout

		ball.update(delay)
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you run this, you'll be able to behold the wonder of the ball moving
 all on its own...
 right off the screen!
\end_layout

\begin_layout Subsubsection
Constraints, part 2
\end_layout

\begin_layout Standard
Naturally this is going to be a very hard game of pong if the ball won't
 stay on the screen.
 Let's add a function to ball.rb:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def check_collision
\end_layout

\begin_layout Plain Layout

		screen = Screen.get_surface()
\end_layout

\begin_layout Plain Layout

		if(@rect.top <= 0 or @rect.bottom > screen.h)
\end_layout

\begin_layout Plain Layout

			@direction[1] = -@direction[1]
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if(@rect.left <= 0 or @rect.right >= screen.w)
\end_layout

\begin_layout Plain Layout

			@direction[0] = - @direction[0]
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And make sure it's called in the update:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		amount = delay * @speed
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@rect.x += @direction[0] * amount;
\end_layout

\begin_layout Plain Layout

		@rect.y += @direction[1] * amount;
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		check_collision
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Running this gives us a slightly better result, in that the ball now bounces
 around the screen.
 It doesn't bounce off of the player's paddle, though.
\end_layout

\begin_layout Standard
There are a few ways to handle this sort of collision detection:
\end_layout

\begin_layout Description
Just
\begin_inset space ~
\end_inset

hack
\begin_inset space ~
\end_inset

it
\begin_inset space ~
\end_inset

together: We could put a function in our game loop that checks to see if
 the ball is colliding with the paddle and, if so, bounce it appropriately.
 This would work for our example, but remember we're going to be shortly
 adding another paddle.
 Any more objects and it'd get really complicated, really quickly.
\end_layout

\begin_layout Description
Dedicated
\begin_inset space ~
\end_inset

collision
\begin_inset space ~
\end_inset

manager: If we had an object whose job it was to keep track of all the sprites
 on screen and test them against each other for collisions, we could put
 all our testing logic in there.
 That way we could add as many objects as we wanted and still have it work.
 Overall, this is one of the better solutions (and one we'll be examining
 later) but it requires that you've planned out your objects and how you
 want them to interact.
 They need to be general enough for a manager to be able to deal with them
 en masse, and we haven't done that yet.
 That leaves a third option:
\end_layout

\begin_layout Description
Let
\begin_inset space ~
\end_inset

the
\begin_inset space ~
\end_inset

objects
\begin_inset space ~
\end_inset

handle
\begin_inset space ~
\end_inset

it: Specifically, we can tell the ball what sprites to look for, and it'll
 check for collisions with them.
 This is also a good solution if you know what objects you're going to be
 potentially colliding with beforehand.
 In our case, we do, so this is the approach we'll take for this example.
\end_layout

\begin_layout Standard
We need to rewrite our ball's constructor to take in the paddles it'll be
 colliding with.
 Change ball.rb's initialize to the following:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def initialize(filename, paddles)
\end_layout

\begin_layout Plain Layout

		@image = Surface.load(filename).convert()
\end_layout

\begin_layout Plain Layout

		@image.colorkey = [255,0,255]
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@rect = Rect.new(0,0,@image.w, @image.h)
\end_layout

\begin_layout Plain Layout

		@paddles = paddles
\end_layout

\begin_layout Plain Layout

		reset
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I'm going to do a little rewriting of our check_collision function, and
 I'm adding a new function called bounce():
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def bounce(index)
\end_layout

\begin_layout Plain Layout

		@direction[index] = -@direction[index]
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def check_collision
\end_layout

\begin_layout Plain Layout

		screen = Screen.get_surface()
\end_layout

\begin_layout Plain Layout

		if(@rect.top <= 0 or @rect.bottom > screen.h)
\end_layout

\begin_layout Plain Layout

			bounce(1)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if(@rect.left <= 0 or @rect.right >= screen.w)
\end_layout

\begin_layout Plain Layout

			bounce(0)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@paddles.each do |paddle|
\end_layout

\begin_layout Plain Layout

			if collide_sprite?(paddle)
\end_layout

\begin_layout Plain Layout

				bounce(0)
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Two new things here:
\end_layout

\begin_layout Subsubsection
Bounce
\end_layout

\begin_layout Standard
The bounce() function takes an index into the 'direction' array and negates
 whatever's there.
 If the index is 0, it changes from right to left or vice versa.
 If it's one, it changes the up/down direction.
 It's basically doing the same thing the old code was doing, only now the
 part that actually changes the direction is on its own.
 This is helpful if we want to do something every time the ball bounces
 (which we will, later).
\end_layout

\begin_layout Subsubsection
collide_sprite?
\end_layout

\begin_layout Standard
This is another gift that the Sprite mixin has given us.
 It takes the rectangle of the current sprite and checks to see if it collides
 with the rectangle of the given sprite.
 If so, we call our 'bounce' function.
\end_layout

\begin_layout Standard
This is a very simple way to do collision detection, and also somewhat wrong.
 We wait until we've already moved the ball to see if it's colliding with
 anything, and only then do we change its direction.
 If the ball or the player is moving fast, it's possible that the direction
 change won't be enough to push the ball away, in which case it'll change
 direction again (because it's still colliding).
 To the player, it'll look like the ball is stuck in the paddle! Fortunately,
 it's unlikely that the player is actually going to move that quickly, so
 in this case we won't take any additional measures.
 We'll address ways to deal with the problem in future projects.
\end_layout

\begin_layout Subsubsection
It doesn't work
\end_layout

\begin_layout Standard
Trying to run our program now will fail, because while we changed the constructo
r for Ball, we never actually changed how we're calling it.
 Go back to pong.rb and change the line that creates the Ball to:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ball = Ball.new("ball.png", [paddle])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Yep, we're passing in an array of one paddle, but that'll change once we
 create another one.
 Run the game and enjoy playing a solitaire version of pong that you can't
 lose.
 At least the ball bounces off your paddle now!
\end_layout

\begin_layout Subsection
Your opponent
\end_layout

\begin_layout Standard
Okay, solitaire is boring, let's add in that other paddle.
 Change your game loop in pong.rb to look like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	paddle = Paddle.new("paddle.png")
\end_layout

\begin_layout Plain Layout

	paddle2 = Paddle.new("paddle.png")
\end_layout

\begin_layout Plain Layout

	paddle2.rect.right = screen.w
\end_layout

\begin_layout Plain Layout

	ball = Ball.new("ball.png", [paddle,paddle2])
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	finished = false
\end_layout

\begin_layout Plain Layout

	while not finished
\end_layout

\begin_layout Plain Layout

		delay = clock.tick.seconds
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		screen.fill( [0, 0, 0] )
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		paddle.draw(screen)
\end_layout

\begin_layout Plain Layout

		paddle2.draw(screen)
\end_layout

\begin_layout Plain Layout

		ball.draw(screen)
\end_layout

\begin_layout Plain Layout

		screen.flip()
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		queue.each do |event|
\end_layout

\begin_layout Plain Layout

			case(event)
\end_layout

\begin_layout Plain Layout

			when Events::QuitRequested
\end_layout

\begin_layout Plain Layout

				finished = true
\end_layout

\begin_layout Plain Layout

			when Events::KeyPressed
\end_layout

\begin_layout Plain Layout

				paddle.key(event.key, true)
\end_layout

\begin_layout Plain Layout

			when Events::KeyReleased
\end_layout

\begin_layout Plain Layout

				paddle.key(event.key, false)
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		paddle.update(delay)
\end_layout

\begin_layout Plain Layout

		paddle2.update(delay)
\end_layout

\begin_layout Plain Layout

		ball.update(delay)
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That snippet of code is getting bigger and bigger, but really all we did
 was add the new paddle, put it over to the right side of the screen, and
 make sure it was getting drawn.
 If you run this, you'll see a two-player pong setup but the right paddle
 will never move.
 We have two ways of doing that:
\end_layout

\begin_layout Description
Add
\begin_inset space ~
\end_inset

more
\begin_inset space ~
\end_inset

controls: The paddle currently looks for the 'up' and 'down' keys to control
 its movement.
 We could change it so that it'd know if it was player1 or player2 and look
 for 'a' and 'z' if it was player 1.
 We'd have to add paddle2.key() calls to the game loop, but it'd be pretty
 simple and is essentially a rehash of what we've already done.
 That's why we're going with option #2:
\end_layout

\begin_layout Description
Have
\begin_inset space ~
\end_inset

the
\begin_inset space ~
\end_inset

computer
\begin_inset space ~
\end_inset

take
\begin_inset space ~
\end_inset

over: We can create a subclass of Paddle that doesn't rely on user input.
 Like the ball, it'll do its own thing.
 In this case, it'll try to move itself as close to the ball as it can.
\end_layout

\begin_layout Standard
We're subclassing paddle rather than creating an entirely new sprite class
 because the only difference is how their update() function works.
 And as you'll see, it's not really that different at all.
 Add this to the bottom of your paddle.rb:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class AIPaddle < Paddle
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	attr_accessor :ball
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		if @ball
\end_layout

\begin_layout Plain Layout

			@keys[:up] = @ball.rect.centery < @rect.centery - 10
\end_layout

\begin_layout Plain Layout

			@keys[:down] = @ball.rect.centery > @rect.centery + 10
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		super(delay)
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That's really all you need.
 If the ball's center is above where the paddle is, it'll move up (by pretending
 its user pushed its 'up' button) and if the ball's center is below, it'll
 move down.
 I put the extra 10 pixels in there so it's not perfect and it isn't moving
 all the time.
\end_layout

\begin_layout Standard
It's easy to see this in action, go back to pong.rb and change the paddle
 setup to:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	paddle = Paddle.new("paddle.png")
\end_layout

\begin_layout Plain Layout

	paddle2 = AIPaddle.new("paddle.png")
\end_layout

\begin_layout Plain Layout

	paddle2.rect.right = screen.w
\end_layout

\begin_layout Plain Layout

	ball = Ball.new("ball.png", [paddle,paddle2])
\end_layout

\begin_layout Plain Layout

	paddle2.ball = ball
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Besides changing Paddle to AIPaddle in the case of paddle2, we also had
 to add a line telling paddle2 where its ball is.
 Otherwise it wouldn't know where to move!
\end_layout

\begin_layout Standard
Run the game and enjoy playing against a flawless opponent in a game you
 can't win or lose.
 Obviously, we're going to have to put some kind of scoring system in if
 we want this game to go anywhere.
\end_layout

\begin_layout Subsection
Text
\end_layout

\begin_layout Standard
Rubygame offers support for two kinds of fonts: SFont and TTF.
 SFont is a bitmap font in use primarily in some linux games and libraries,
 while TTF is in wide use by both linux and windows systems.
 Given TTF's relative ubiquity and the ease of finding new fonts for it,
 this book will concentrate on the latter.
\end_layout

\begin_layout Standard
We'll be using the free Bitstream Vera font from the GNOME collection throughout
 the book - it's included in this book's accompanying source code and is
 available under a very liberal license (essentially, you can use it in
 whatever games you want).
\end_layout

\begin_layout Standard
The first part of using the TTF library is setting it up - like Rubygame,
 it also needs to have a setup function called before it can be used.
 So back in pong.rb, add this to the beginning of main():
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def main()
\end_layout

\begin_layout Plain Layout

	Rubygame.init()
\end_layout

\begin_layout Plain Layout

	Rubygame::TTF.setup()
\end_layout

\begin_layout Plain Layout

	flags = [HWSURFACE, DOUBLEBUF]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next, we're going to use what we can from our sprite mixin.
 Because a TTF can't just be drawn like an ordinary image, we have to get
 a bit fancy.
 Here's what score.rb looks like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'rubygame'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

include Rubygame
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Scoreboard
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	include Sprites::Sprite
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	attr_reader :score
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def initialize(filename, initial_score = 0)
\end_layout

\begin_layout Plain Layout

		@font = TTF.new(filename, 18)
\end_layout

\begin_layout Plain Layout

		@rect = Rect.new(0,0,0,0)
\end_layout

\begin_layout Plain Layout

		self.score = initial_score
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def score=(new_score)
\end_layout

\begin_layout Plain Layout

		@score = new_score
\end_layout

\begin_layout Plain Layout

		@image = @font.render(
\end_layout

\begin_layout Plain Layout

			@score.to_s,     # The text to render
\end_layout

\begin_layout Plain Layout

			true,            # Do we want antialiasing?
\end_layout

\begin_layout Plain Layout

			[255,255,255])   # The color of the text
\end_layout

\begin_layout Plain Layout

		@rect.w = @image.w
\end_layout

\begin_layout Plain Layout

		@rect.h = @image.h
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This one has a filename like the ones that made images, but unlike them
 we use it to load a TTF.
 The next thing we do is to create a rectangle with no width or height.
 Again, unlike the images we can't know what size this will be until we
 try to draw a string using it.
 Next, we use the 'score=' function to do exactly that.
\end_layout

\begin_layout Subsubsection
Rendering text
\end_layout

\begin_layout Standard
You can't directly blit a font to the screen like you can with an image.
 Instead, the TTF.render() function creates a Surface, and you can use that.
 We opt to do this once, when the score changes, rather than every frame,
 which would get a bit slow.
 Once we've actually put the text onto a surface, we can then measure that
 surface and set our @rect accordingly.
\end_layout

\begin_layout Subsubsection
Adding more objects
\end_layout

\begin_layout Standard
The game loop is getting incredibly crowded at this point! pong.rb's loop
 should look like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	paddle = Paddle.new("paddle.png")
\end_layout

\begin_layout Plain Layout

	paddle2 = AIPaddle.new("paddle.png")
\end_layout

\begin_layout Plain Layout

	paddle2.rect.right = screen.w
\end_layout

\begin_layout Plain Layout

	ball = Ball.new("ball.png", [paddle,paddle2])
\end_layout

\begin_layout Plain Layout

	paddle2.ball = ball
\end_layout

\begin_layout Plain Layout

	scores = [
\end_layout

\begin_layout Plain Layout

		Scoreboard.new("VeraMoBd.ttf"),
\end_layout

\begin_layout Plain Layout

		Scoreboard.new("VeraMoBd.ttf")
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

	scores[0].rect.x = 60
\end_layout

\begin_layout Plain Layout

	scores[1].rect.right = screen.w - 60
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	finished = false
\end_layout

\begin_layout Plain Layout

	while not finished
\end_layout

\begin_layout Plain Layout

		delay = clock.tick.seconds
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		screen.fill( [0, 0, 0] )
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		paddle.draw(screen)
\end_layout

\begin_layout Plain Layout

		paddle2.draw(screen)
\end_layout

\begin_layout Plain Layout

		ball.draw(screen)
\end_layout

\begin_layout Plain Layout

		scores.each do |board|
\end_layout

\begin_layout Plain Layout

			board.draw(screen)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		screen.flip()
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		queue.each do |event|
\end_layout

\begin_layout Plain Layout

			case(event)
\end_layout

\begin_layout Plain Layout

			when Events::QuitRequested
\end_layout

\begin_layout Plain Layout

				finished = true
\end_layout

\begin_layout Plain Layout

			when Events::KeyPressed
\end_layout

\begin_layout Plain Layout

				paddle.key(event.key, true)
\end_layout

\begin_layout Plain Layout

			when Events::KeyReleased
\end_layout

\begin_layout Plain Layout

				paddle.key(event.key, false)
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		paddle.update(delay)
\end_layout

\begin_layout Plain Layout

		paddle2.update(delay)
\end_layout

\begin_layout Plain Layout

		ball.update(delay)
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Again, a lot of text for relatively few changes.
 We created the scoreboards in an array and then later painted them to the
 screen.
 Note that we don't call update() on them, as they are only going to change
 when the score changes.
 Speaking of which, when is that happening?
\end_layout

\begin_layout Subsection
Callbacks
\end_layout

\begin_layout Standard
The check_collision function of the Ball object already knows if we've gone
 off either side of the screen, so it would seem the logical place to change
 the score would be there.
 There's only one problem: The ball doesn't know anything about the scoreboard.
\end_layout

\begin_layout Standard
As before, there are a few ways to handle this.
 We could do the same thing we did with the paddles and explicitly pass
 the scoreboards in, but this even further tightly couples the ball to the
 rest of the objects in the game.
 The more things we add to the ball object, the more complicated it gets
 and the more variables we need to keep track of.
 We don't want it to look like the game loop up there, after all!
\end_layout

\begin_layout Standard
Another way to handle this is via a callback.
 Essentially, we write a function that handles scoring, and we tell the
 Ball object to call that function when the subject comes up.
 Here's how we'll use it in pong.rb:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	scores = [
\end_layout

\begin_layout Plain Layout

		Scoreboard.new("VeraMoBd.ttf"),
\end_layout

\begin_layout Plain Layout

		Scoreboard.new("VeraMoBd.ttf")
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

	scores[0].rect.x = 60
\end_layout

\begin_layout Plain Layout

	scores[1].rect.right = screen.w - 60
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	ball.when_score do |index|
\end_layout

\begin_layout Plain Layout

		scores[index].score += 1
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pretty simple, really, at least from this side of the equation.
 Of course, running this will fail miserably because we haven't written
 the when_score function yet.
 Go over to ball.rb and add these two functions:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def announce_score(index)
\end_layout

\begin_layout Plain Layout

		if @score_callback
\end_layout

\begin_layout Plain Layout

			@score_callback.call(index)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def when_score(&block)
\end_layout

\begin_layout Plain Layout

		@score_callback = block
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This will make the game run, but points still aren't scored.
 That's because we need to change the way check_collision works:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def check_collision
\end_layout

\begin_layout Plain Layout

		screen = Screen.get_surface()
\end_layout

\begin_layout Plain Layout

		if(@rect.top <= 0 or @rect.bottom > screen.h)
\end_layout

\begin_layout Plain Layout

			bounce(1)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if(@rect.left <= 0)
\end_layout

\begin_layout Plain Layout

			announce_score(1)
\end_layout

\begin_layout Plain Layout

			reset
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		if(@rect.right >= screen.w)
\end_layout

\begin_layout Plain Layout

			announce_score(0)
\end_layout

\begin_layout Plain Layout

			reset
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@paddles.each do |paddle|
\end_layout

\begin_layout Plain Layout

			if collide_sprite?(paddle)
\end_layout

\begin_layout Plain Layout

				bounce(0)
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So, flow of scoring goes as follows:
\end_layout

\begin_layout Enumerate
At the beginning of the game, we call when_score with a block of code that
 adds '1' to whichever side scored.
 Because calling score= on the Scoreboard object causes it to re-draw its
 image, that one line of code is all we have to do to update the score.
\end_layout

\begin_layout Enumerate
Later, when the ball goes off the edge, the check_collision function figures
 out who let it through, and announces that the other side should get a
 point
\end_layout

\begin_layout Enumerate
The announce_score function calls the block of code that was set aside earlier
 and informs it of the side that scored.
\end_layout

\begin_layout Standard
Callbacks are a very powerful way to de-couple your objects.
 Notice that the Ball didn't need to know anything about the Scoreboards
 or how they worked.
 We could replace the scoreboards with smilie-face sprites that light up
 depending on how high your score is, and we wouldn't have to change a single
 line of code in ball.rb to deal with it.
\end_layout

\begin_layout Subsection
Winning and Losing
\end_layout

\begin_layout Standard
This game is...
 boring.
 The computer still plays a flawless game and the ball moves slowly enough
 that it's probably pretty easy for you to keep it going.
 We need some challenge.
 Remember earlier when I made ball.rb's 
\begin_inset Quotes eld
\end_inset

bounce
\begin_inset Quotes erd
\end_inset

 functionality into a separate function? Change it as follows and you'll
 see why:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def bounce(index)
\end_layout

\begin_layout Plain Layout

		@direction[index] = -@direction[index]
\end_layout

\begin_layout Plain Layout

		@speed *= 1.1
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Play that, and you'll soon have a challenge on your hands! Each time the
 ball bounces, whether against a paddle or the wall, it speeds up by 10%.
 If you're quick, you can win simply because the computer tries to move
 toward where the ball currently is, rather than where it will be.
\end_layout

\begin_layout Standard
The game, while at least a bit exciting now, has a tendency to go on forever.
 This is because we haven't put any win conditions in.
 Here are some simple ones to add to the bottom of the loop in pong.rb:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		paddle.update(delay)
\end_layout

\begin_layout Plain Layout

		paddle2.update(delay)
\end_layout

\begin_layout Plain Layout

		ball.update(delay)
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if scores[0].score > 15
\end_layout

\begin_layout Plain Layout

			raise "Game over - you win!"
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if scores[1].score > 15
\end_layout

\begin_layout Plain Layout

			raise "Game over - you lose!"
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Raising an exception is hardly the most elegant way to congratulate a winner,
 but for now it gets our job done.
\end_layout

\begin_layout Subsection
Wrapup
\end_layout

\begin_layout Standard
Here's what you've accomplished over the previous demo:
\end_layout

\begin_layout Itemize
You use Sprites to put things on the screen now, rather than drawing it
 yourself,
\end_layout

\begin_layout Itemize
The sprites know how to react to user input
\end_layout

\begin_layout Itemize
They can move on their own
\end_layout

\begin_layout Itemize
You can check for collisions
\end_layout

\begin_layout Itemize
You can draw text as a sprite, and
\end_layout

\begin_layout Itemize
You can win or lose.
 
\end_layout

\begin_layout Standard
Congratulations, you've made your first Rubygame game!
\end_layout

\begin_layout Standard
While most of the code is far more elegant than the initial run, there's
 still a lot that can be done.
 The ball is fairly highly coupled with the paddles, for instance, and all
 our game objects live in the game loop.
 Also, every object that's in the game is created at the beginning - nothing's
 ever added or removed.
 What if you want to create new sprites on the fly, or get rid of them?
 That's what we'll be covering next when we re-make another game.
\end_layout

\begin_layout Section
Asteroids
\end_layout

\begin_layout Standard
The original Asteroids was released in 1979.
 We're moving up the technology tree now!
\end_layout

\begin_layout Subsection
A Game Engine
\end_layout

\begin_layout Standard
Before, every time we wanted to add another sprite to our game, we had to
 go through a number of hoops.
 We had to put it in another variable, draw it, update it, and, if necessary,
 pass keystrokes to it.
 Even more annoyingly, these steps were exactly the same for each new sprite.
 Wouldn't it be handy if we had a more standard way of doing that?
\end_layout

\begin_layout Standard
Yes.
 Yes it would.
 So let's do that.
 We're going to make a small game engine that'll take over a lot of the
 duties that our main() function was handling before.
 It'll keep hold of the screen and draw and update anything we tell it to.
 The code to do this is a bit long, but it should look familiar from earlier
 examples:
\end_layout

\begin_layout Standard
engine.rb
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'rubygame'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

include Rubygame
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Engine
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	attr_accessor :flags
\end_layout

\begin_layout Plain Layout

	attr_accessor :screen_width
\end_layout

\begin_layout Plain Layout

	attr_accessor :screen_height
\end_layout

\begin_layout Plain Layout

	attr_accessor :running
\end_layout

\begin_layout Plain Layout

	attr_accessor :bgcolor
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def initialize()
\end_layout

\begin_layout Plain Layout

		Rubygame.init()
\end_layout

\begin_layout Plain Layout

		@flags = [HWSURFACE, DOUBLEBUF]
\end_layout

\begin_layout Plain Layout

		@screen_width = 640
\end_layout

\begin_layout Plain Layout

		@screen_height = 480
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@clock = Clock.new
\end_layout

\begin_layout Plain Layout

		@clock.enable_tick_events()
\end_layout

\begin_layout Plain Layout

		target_framerate=30
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@queue = EventQueue.new()
\end_layout

\begin_layout Plain Layout

		@queue.enable_new_style_events()
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@bgcolor = [ 0, 0, 0 ]
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	# Lazy initialization for screen
\end_layout

\begin_layout Plain Layout

	def screen
\end_layout

\begin_layout Plain Layout

		if not @screen
\end_layout

\begin_layout Plain Layout

			resolution = [@screen_width, @screen_height]
\end_layout

\begin_layout Plain Layout

			@screen = Screen.new( resolution, 0, @flags )
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		return @screen
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def target_framerate=(value)
\end_layout

\begin_layout Plain Layout

		@clock.target_framerate = value
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def run
\end_layout

\begin_layout Plain Layout

		@running = true
\end_layout

\begin_layout Plain Layout

		while running
\end_layout

\begin_layout Plain Layout

			delay = @clock.tick.seconds
\end_layout

\begin_layout Plain Layout

			screen.fill( @bgcolor )
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			# TODO: Drawing
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			screen.flip()
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			@queue.each do |event|
\end_layout

\begin_layout Plain Layout

				case(event)
\end_layout

\begin_layout Plain Layout

				when Events::QuitRequested
\end_layout

\begin_layout Plain Layout

					@running = false
\end_layout

\begin_layout Plain Layout

				end
\end_layout

\begin_layout Plain Layout

				# TODO: Other events
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			# TODO: Updating
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is pretty much the same thing as we've been doing, except I've replaced
 the parts of the engine that might actually help us with #TODO statements.
 We'll be filling them in later with actual code.
\end_layout

\begin_layout Subsubsection
Lazy Initialization
\end_layout

\begin_layout Standard
We set up everything in our initialize() pretty much the same way we did
 before.
 The only difference is that we've put the screen creation in an accessor
 function.
 Why did we do this, rather than in the initialize() function?
\end_layout

\begin_layout Standard
The simple answer is that we don't want to set up the screen until we're
 ready for it.
 The initialize function is going to be called early on, but we might want
 to do other things before we decide what resolution or flags we want.
 So this way we can create a new instance of the Engine, do whatever other
 things we need to, and then pass in resolutions all before we use the screen.
 For example, here's a pretty minimal bit of code that uses the engine:
\end_layout

\begin_layout Standard
simple.rb
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'engine'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def main
\end_layout

\begin_layout Plain Layout

	engine = Engine.new
\end_layout

\begin_layout Plain Layout

	engine.screen_width = 1024
\end_layout

\begin_layout Plain Layout

	engine.screen_height = 768
\end_layout

\begin_layout Plain Layout

	engine.run
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if __FILE__ == $0
\end_layout

\begin_layout Plain Layout

	main()
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here, we tell our engine to use a different resolution than its default.
 If we'd set up the screen to be created during Initialize, then we'd have
 had to pass in things like resolution or flags - after a while we'd end
 up passing in quite a bit!
\end_layout

\begin_layout Standard
Note that we're not actually using the 'screen' variable at all.
 That's another way that lazy initialization helps out - it allows you to
 set up pretty complicated defaults.
 If you don't explicitly do anything with the screen earlier, the first
 time it's used is at the beginning of the 'run' function, which creates
 it then.
\end_layout

\begin_layout Subsubsection
Sprite Groups
\end_layout

\begin_layout Standard
We've got a number of TODO statements up there.
 Whereas before we had a variable for every object we were keeping track
 of, this time we'll just keep an array in the engine.
 That way we can update and draw everything that needs to be updated and
 drawn all in one spot, and if we wanted to add another sprite the only
 thing we have to do is add to the array.
\end_layout

\begin_layout Standard
First, let's add an array accessor and set it up in the initialize function:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	attr_accessor :components
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def initialize()
\end_layout

\begin_layout Plain Layout

		Rubygame.init()
\end_layout

\begin_layout Plain Layout

		@flags = [HWSURFACE, DOUBLEBUF]
\end_layout

\begin_layout Plain Layout

		@screen_width = 640
\end_layout

\begin_layout Plain Layout

		@screen_height = 480
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@clock = Clock.new
\end_layout

\begin_layout Plain Layout

		@clock.enable_tick_events()
\end_layout

\begin_layout Plain Layout

		target_framerate=30
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@queue = EventQueue.new()
\end_layout

\begin_layout Plain Layout

		@queue.enable_new_style_events()
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@bgcolor = [ 0, 0, 0 ]
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@components = Sprites::Group.new()
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That's no array!
\end_layout

\begin_layout Standard
Nope - because the idea of putting sprites into an array and then drawing
 and/or updating them is so common, Rubygame provides specialized arrays
 called Sprite Groups.
 They're subclasses of Array, so they can do everything that an ordinary
 array could, but they also include specialized functions just for sprites.
\end_layout

\begin_layout Standard
With that in mind, let's replace some of those TODOs.
 First, replace the line that says 
\begin_inset Quotes eld
\end_inset

# TODO: Drawing
\begin_inset Quotes erd
\end_inset

 with:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@components.draw(screen)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 'draw' function is one of the things that the Group class gives us.
 It goes through every sprite in the group and draws it to the surface you
 supply; in this case the screen.
\end_layout

\begin_layout Standard
Updating works similarly, replace the 
\begin_inset Quotes eld
\end_inset

TODO: Updating
\begin_inset Quotes erd
\end_inset

 with:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@components.update(delay)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this case, Group's 
\begin_inset Quotes eld
\end_inset

update
\begin_inset Quotes erd
\end_inset

 function takes any number of arguments.
 It then calls the 'update' function of every sprite in the collection and
 passes whatever arguments you gave.
 Importantly, the Sprite mixin creates a 'draw' function for you, but it
 doesn't add in an 'update'.
 If you're going to use the above functionality, you're going to have to
 add in an update function of your own.
 We'll come back to that soon.
\end_layout

\begin_layout Standard
So Group provides us with a built-in way to call 'draw' and 'update' on
 everything, but what if you wanted to call some other function on everything?
 It's still an array so you could iterate through it like any other, but
 Group provides us a simpler way.
 In the previous chapter, we had a 'key' function and dictionary that kept
 track of the state of the keyboard.
 Let's re-write our event loop to use something like that:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

			@queue.each do |event|
\end_layout

\begin_layout Plain Layout

				case(event)
\end_layout

\begin_layout Plain Layout

				when Events::QuitRequested
\end_layout

\begin_layout Plain Layout

					@running = false
\end_layout

\begin_layout Plain Layout

				when Events::QuitRequested
\end_layout

\begin_layout Plain Layout

					finished = true
\end_layout

\begin_layout Plain Layout

				when Events::KeyPressed
\end_layout

\begin_layout Plain Layout

					@components.call(:key, event.key, true)
\end_layout

\begin_layout Plain Layout

				when Events::KeyReleased
\end_layout

\begin_layout Plain Layout

					@components.call(:key, event.key, false)
\end_layout

\begin_layout Plain Layout

				end
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Group::call does the same thing that 'draw' and 'update' does, but on a
 more general level.
 It calls whatever function you specify (in this case 'key') and passes
 in whatever arguments you give it; it does this for every sprite in the
 group.
 Like 'update', it doesn't check to see if that function actually exists,
 so if you use 'call' be sure to define the function you're calling.
\end_layout

\begin_layout Subsection
Components
\end_layout

\begin_layout Standard
In our previous Pong example, there was some duplicated code.
 Both the Ball and Paddle class took a filename and created a surface from
 it, converted it and set its colorkey.
 As mentioned in the previous section, we also need to define an 'update'
 and 'key' function in every sprite we use.
\end_layout

\begin_layout Standard
We're going to create a base class for every sprite we put on the screen,
 so that all these functions will be defined.
 Let's put it at the top of engine.rb:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Component
\end_layout

\begin_layout Plain Layout

	include Sprites::Sprite
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def initialize(filename)
\end_layout

\begin_layout Plain Layout

		@filename = filename
\end_layout

\begin_layout Plain Layout

		@image = Surface.load(filename).convert()
\end_layout

\begin_layout Plain Layout

		@image.colorkey = [255,0,255]
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@rect = Rect.new(0,0,@image.w, @image.h)
\end_layout

\begin_layout Plain Layout

		@keys = {}
\end_layout

\begin_layout Plain Layout

		super()
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def key(sym, pressed)
\end_layout

\begin_layout Plain Layout

		@keys[sym] = pressed
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Sprite mixin gives us the 'draw' function, just like before.
 We've created an 'update' function that doesn't do anything - this is so
 our call to Group::update won't error out.
 All the other code should look familiar - it's the same kind of thing we
 did in the previous chapter, only now we've put it all in one place.
 Everything we put on the screen will be a subclass of Component.
\end_layout

\begin_layout Subsubsection
The Ship
\end_layout

\begin_layout Standard
Let's create our first component, then: The Player's ship
\end_layout

\begin_layout Standard
ship.rb
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'engine'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Ship < Component
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def initialize
\end_layout

\begin_layout Plain Layout

		super("ship.png")
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		if @keys[:up]
\end_layout

\begin_layout Plain Layout

			@rect.top -= delay * 100
\end_layout

\begin_layout Plain Layout

		elsif @keys[:down]
\end_layout

\begin_layout Plain Layout

			@rect.top += delay * 100
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if @keys[:left]
\end_layout

\begin_layout Plain Layout

			@rect.left -= delay * 100
\end_layout

\begin_layout Plain Layout

		elsif @keys[:right]
\end_layout

\begin_layout Plain Layout

			@rect.right += delay * 100
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here we override the default empty 
\begin_inset Quotes eld
\end_inset

update
\begin_inset Quotes erd
\end_inset

 function to give the ship the ability to move around in response to keypresses.
 Because there's ever only going to be one ship and it's always going to
 look the same, the Ship's initialize function calls its superclass with
 'ship.png'.
 If we had something that behaved like the ship but looked differently,
 we'd probably keep the 'filename' argument, but in this case we don't need
 it.
\end_layout

\begin_layout Subsubsection
A Basic Skeleton
\end_layout

\begin_layout Standard
We've got a lot of framework out of the way, but we haven't actually done
 anything with it.
 Let's create a program that actually uses our framework!
\end_layout

\begin_layout Standard
asteroids.rb
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'engine'
\end_layout

\begin_layout Plain Layout

require 'ship'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def main
\end_layout

\begin_layout Plain Layout

	engine = Engine.new
\end_layout

\begin_layout Plain Layout

	engine.screen_width = 1024
\end_layout

\begin_layout Plain Layout

	engine.screen_height = 768
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	engine.screen
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	ship = Ship.new
\end_layout

\begin_layout Plain Layout

	engine.components << ship
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	engine.run
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if __FILE__ == $0
\end_layout

\begin_layout Plain Layout

	main()
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you run this, you'll see it's about as impressive as the end of chapter
 1, when you could move something around.
 We've gone through a lot of work and don't have a lot to show off.
 In fact, if you've ever played asteroids before you've noticed something
 about the way we move the ship around: It's entirely wrong!
\end_layout

\begin_layout Standard
In Asteroids, turning left or right rotate that ship in that direction and
 pressing forward accelerates.
 You can only fire directly ahead, so the inability to turn would be a large
 hindrance.
 Not to mention that the original game had the ship keep moving even after
 the player stopped pressing the button.
 How can we model that?
\end_layout

\begin_layout Subsubsection
Let's Get Physical
\end_layout

\begin_layout Standard
Science! Specifically, physics.
 Even more specifically, Newton's First Law: An object in motion tends to
 remain in motion.
 In order to model this, we need to keep a variable of how fast (and in
 what direction) we're traveling.
 This is actually similar to the Ball class in the previous chapter.
 In the same way we remembered what to add to its 'x' and 'y', we'll be
 keeping a 'velocity' array to do the same thing.
\end_layout

\begin_layout Standard
But where to keep this functionality? We could add this on to our Component,
 but remember that Component is our superclass for everything that shows
 up on screen.
 This includes things like the score, which doesn't even move at all.
 It'd be wasted functionality for anything that didn't preserve momentum
 - or anything that moves but does so in a different way.
\end_layout

\begin_layout Standard
Instead, let's make a subclass of Component that handles momentum.
 Put this between Component and the Engine itself:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class InertialComponent < Component
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	attr_accessor :top_speed
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def initialize(filename)
\end_layout

\begin_layout Plain Layout

		super
\end_layout

\begin_layout Plain Layout

		@top_speed = 100
\end_layout

\begin_layout Plain Layout

		@velocity = [ 0.0, 0.0 ]
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def accelerate(dx,dy)
\end_layout

\begin_layout Plain Layout

		@velocity[0] += dx
\end_layout

\begin_layout Plain Layout

		@velocity[1] += dy
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		# This is the part where we enforce the top speed
\end_layout

\begin_layout Plain Layout

		speed_squared = @velocity[0] * @velocity[0] +
\end_layout

\begin_layout Plain Layout

			@velocity[1] * @velocity[1]
\end_layout

\begin_layout Plain Layout

		if speed_squared > @top_speed * @top_speed
\end_layout

\begin_layout Plain Layout

			clamp_velocity(speed_squared)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	# If we're going faster than our top speed, change the speed to
\end_layout

\begin_layout Plain Layout

	# be the top speed
\end_layout

\begin_layout Plain Layout

	def clamp_velocity(speed_squared)
\end_layout

\begin_layout Plain Layout

		speed = Math.sqrt(speed_squared)
\end_layout

\begin_layout Plain Layout

		# Convert our velocity to a unit vector
\end_layout

\begin_layout Plain Layout

		unit_x = @velocity[0] / speed
\end_layout

\begin_layout Plain Layout

		unit_y = @velocity[1] / speed
\end_layout

\begin_layout Plain Layout

		# Now scale it back up to the top speed
\end_layout

\begin_layout Plain Layout

		@velocity = [unit_x * @top_speed, unit_y * @top_speed]
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		@rect.x += @velocity[0] * delay
\end_layout

\begin_layout Plain Layout

		@rect.y += @velocity[1] * delay
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Some of this looks familiar - the velocity stuff is similar to the Ball,
 but we've got a number of other things in there as well.
 We've put in a top speed and an 
\begin_inset Quotes eld
\end_inset

accelerate
\begin_inset Quotes erd
\end_inset

 function, and 
\begin_inset Quotes eld
\end_inset

clamp_velocity
\begin_inset Quotes erd
\end_inset

 makes sure it doesn't go over that max speed.
 The math involved is quite a bit of vector math, and as it happens Rubygame
 has a built-in class to handle vector math.
 If you're curious, Rubygame::Ftor is this class - but note that it's going
 away in Rubygame 3.0.
 That's why we're going with the basic operations here.
\end_layout

\begin_layout Standard
Let's re-write the Ship class to take advantage of this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Ship < InertialComponent
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def initialize
\end_layout

\begin_layout Plain Layout

		super("ship.png")
\end_layout

\begin_layout Plain Layout

		@top_speed = 400
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		if @keys[:up]
\end_layout

\begin_layout Plain Layout

			accelerate(0,-1)
\end_layout

\begin_layout Plain Layout

		elsif @keys[:down]
\end_layout

\begin_layout Plain Layout

			accelerate(0, 1)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		super
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you run the program now, tap the 'up' key.
 The ship will slowly start wandering off the screen.
 Hold down the 'down' arrow and it'll back up and start moving in the other
 direction.
 It'll keep going, even after you let go.
\end_layout

\begin_layout Standard
That takes care of the momentum problem, but there's still no way to actually
 rotate the ship! In order to do that, we'll have to keep track of the ship's
 angle, rotate the image whenever that angle changes, and make it so that
 when you accelerate, you accelerate in the direction you're pointing rather
 than just straight ahead.
\end_layout

\begin_layout Standard
This means we're re-writing our ship class, again:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Ship < InertialComponent
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def initialize
\end_layout

\begin_layout Plain Layout

		super("ship.png")
\end_layout

\begin_layout Plain Layout

		@top_speed = 400
\end_layout

\begin_layout Plain Layout

		@original_image = @image
\end_layout

\begin_layout Plain Layout

		self.angle = 0
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def angle=(value)
\end_layout

\begin_layout Plain Layout

		@angle = value
\end_layout

\begin_layout Plain Layout

		@image = @original_image.rotozoom(@angle, 1.0).convert
\end_layout

\begin_layout Plain Layout

		@image.colorkey = [255, 0, 255]
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		# Because the image might end up a different size than before,
\end_layout

\begin_layout Plain Layout

		# we need to change our @rect accordingly
\end_layout

\begin_layout Plain Layout

		old_center = @rect.center
\end_layout

\begin_layout Plain Layout

		@rect.w = @image.w
\end_layout

\begin_layout Plain Layout

		@rect.h = @image.h
\end_layout

\begin_layout Plain Layout

		@rect.center = old_center
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		radians = @angle * Math::PI / 180
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		if @keys[:up]
\end_layout

\begin_layout Plain Layout

			accelerate(Math.cos(radians) * 5,-Math.sin(radians) * 5)
\end_layout

\begin_layout Plain Layout

		elsif @keys[:down]
\end_layout

\begin_layout Plain Layout

			accelerate(-Math.cos(radians) * 5,Math.sin(radians) * 5)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if @keys[:left]
\end_layout

\begin_layout Plain Layout

			self.angle = @angle + 90 * delay
\end_layout

\begin_layout Plain Layout

		elsif @keys[:right]
\end_layout

\begin_layout Plain Layout

			self.angle = @angle - 90 * delay
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		super
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Rotozoom
\end_layout

\begin_layout Standard
Surface's 
\begin_inset Quotes eld
\end_inset

rotozoom
\begin_inset Quotes erd
\end_inset

 functionality does exactly what it sounds like: It gives you an image that's
 rotated and/or zoomed by the amounts you give it.
 Because this isn't necessarily a lossless operation, we rotate the original
 image rather than continually rotating ones that have already been rotated.
 We aren't interested in scaling our sprite at all, so we just pass in '1'
 as our zoom factor.
 The rotozoom function might return a surface that's a different size than
 the original surface (because otherwise the rotated image wouldn't fit),
 so we need to change our @rect information.
 Because the new image is a different size but the ship itself is still
 in the middle of the image, we need to re-center it to prevent it from
 appearing off-center as it was rotated.
\end_layout

\begin_layout Subsubsection
Trigonometry
\end_layout

\begin_layout Standard
This is the kind of vector math that we're doing ourselves in this book.
 When the ship was just facing up, it was easy to know what to add to its
 
\begin_inset Quotes eld
\end_inset

y
\begin_inset Quotes erd
\end_inset

 position and 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 position when the player accelerates.
 When the ship's at a 14 degree angle, on the other hand, it's a bit more
 difficult.
 Essentially, we accelerate the ship by the portion of its angle that applies
 to X, and the portion that applies to Y.
 As shown above, you can get those numbers by the cosine of the angle and
 the sine of the angle.
 We negate the 'y' portion because the screen's 
\begin_inset Quotes eld
\end_inset

y
\begin_inset Quotes erd
\end_inset

 increases as you go from top to bottom, which is the opposite of ordinary
 math.
\end_layout

\begin_layout Standard
If you run the game at this point, you now have a ship that's functional!
 Of course, it's missing a little something from the title - the asteroids!
\end_layout

\begin_layout Subsection
Asteroids
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
\start_of_appendix
Key Symbol Cheatsheet
\begin_inset CommandInset label
LatexCommand label
name "sec:Key-Symbol-Cheatsheet"

\end_inset


\end_layout

\begin_layout Subsection
Official List
\end_layout

\begin_layout Standard
You can find a list of all key symbols in the Rubygame API documentation
 via the 
\begin_inset Quotes eld
\end_inset

doc/keyboard_symbols.rdoc
\begin_inset Quotes erd
\end_inset

 link or via the Rubygame Wiki at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://rubygame.org/wiki/Keyboard_Symbols
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Guide
\end_layout

\begin_layout Standard
Here are some basic rules for how the key symbols are generated:
\end_layout

\begin_layout Description
Characters
\begin_inset space ~
\end_inset

A-Z: Are simply the symbol versions of themselves.
\end_layout

\begin_layout Description
Numbers: Are prefixed with 
\begin_inset Quotes eld
\end_inset

number_
\begin_inset Quotes erd
\end_inset

 for ordinary numbers, or 
\begin_inset Quotes eld
\end_inset

keypad_
\begin_inset Quotes erd
\end_inset

 for the ones on the numeric keypad.
\end_layout

\begin_layout Description
Function
\begin_inset space ~
\end_inset

Keys: Are prefixed with 
\begin_inset Quotes eld
\end_inset

f
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Category
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Example
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Example
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Characters
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 => :a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 => :x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Numbers
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 => :number_1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 => :keypad_5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function Keys
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F5 => :f5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F12 => :f12
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Cheatsheet.rb
\end_layout

\begin_layout Standard
Here's a program you can use if you want to know what the symbol for any
 given key is:
\end_layout

\begin_layout Standard
cheatsheet.rb
\end_layout

\begin_layout LyX-Code
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout

require 'rubygame'
\end_layout

\begin_layout Plain Layout

include Rubygame
\end_layout

\begin_layout Plain Layout

Rubygame.init()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

screen = Screen.new( [640,480] ) # The size of the window we want
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

queue = EventQueue.new()
\end_layout

\begin_layout Plain Layout

queue.enable_new_style_events()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

finished = false
\end_layout

\begin_layout Plain Layout

while not finished
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	queue.each do | event |
\end_layout

\begin_layout Plain Layout

		case(event)
\end_layout

\begin_layout Plain Layout

		when Events::QuitRequested
\end_layout

\begin_layout Plain Layout

			finished = true
\end_layout

\begin_layout Plain Layout

		when Events::KeyPressed
\end_layout

\begin_layout Plain Layout

			puts "#{event.string} pressed, "+
\end_layout

\begin_layout Plain Layout

				"mods are: #{event.modifiers.join(',')} "+
\end_layout

\begin_layout Plain Layout

				"symbol is: :#{event.key}"
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	Clock.wait(100)
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Rubygame.quit()
\end_layout

\end_inset


\end_layout

\begin_layout Section
Full Code Listings
\end_layout

\begin_layout Section
License
\end_layout

\begin_layout Subsection
Code
\end_layout

\begin_layout Standard
A book full of code isn't of much use if you can't actually use any of the
 code! So in the spirit of letting you get the most out of the examples,
 I'm using the MIT License for the code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Copyright (c) 2011 Roger Ostrander
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Permission is hereby granted, free of charge, to any person obtaining a
 copy
\end_layout

\begin_layout Plain Layout

of this software and associated documentation files (the "Software"), to
 deal
\end_layout

\begin_layout Plain Layout

in the Software without restriction, including without limitation the rights
\end_layout

\begin_layout Plain Layout

to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
\end_layout

\begin_layout Plain Layout

copies of the Software, and to permit persons to whom the Software is
\end_layout

\begin_layout Plain Layout

furnished to do so, subject to the following conditions:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

The above copyright notice and this permission notice shall be included
 in
\end_layout

\begin_layout Plain Layout

all copies or substantial portions of the Software.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 OR
\end_layout

\begin_layout Plain Layout

IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
\end_layout

\begin_layout Plain Layout

FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE
\end_layout

\begin_layout Plain Layout

AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
\end_layout

\begin_layout Plain Layout

LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 FROM,
\end_layout

\begin_layout Plain Layout

OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
\end_layout

\begin_layout Plain Layout

THE SOFTWARE.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Text (and some assets)
\end_layout

\begin_layout Standard
All the text in this book is licensed under the Creative Commons Attribution
 license.
 Any of the image assets that I personally created are also available under
 this same license.
 License text is available at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://creativecommons.org/licenses/by/3.0/
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Things I Didn't Make
\end_layout

\begin_layout Subsubsection
ttf-bitstream-vera-1.10
\end_layout

\begin_layout Standard
The Bitstream Vera font is from the people who made GNOME, and they've made
 it available under a fairly permissive license.
 Consult the COPYRIGHT.TXT file included in the directory for usage details.
\end_layout

\begin_layout Subsubsection
rubygame.png
\end_layout

\begin_layout Standard
This is the Rubygame logo, and it comes with the Rubygame distribution.
 It (as well as a few other sample images that come with the distribution)
 are licensed under the Creative Commons Attribution-ShareAlike 2.5 License,
 viewable at 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://creativecommons.org/licenses/by-sa/2.5/ 
\end_layout

\end_inset


\end_layout

\end_body
\end_document
