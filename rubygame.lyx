#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Ruby Gaming with Rubygame
\end_layout

\begin_layout Author
by Roger Ostrander
\end_layout

\begin_layout Part
Basics
\end_layout

\begin_layout Section
A Very Simple Rubygame Program
\begin_inset CommandInset label
LatexCommand label
name "sec:A-Very-Simple"

\end_inset


\end_layout

\begin_layout Subsection
Bare Bones
\end_layout

\begin_layout Standard
I use the word 'program' up there because this isn't really a game.
 For our first foray into Rubygame, we're just going to write something
 that displays an image on the screen.
\end_layout

\begin_layout Standard
very_first.rb
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout

# Every rubygame program you run is going to require this
\end_layout

\begin_layout Plain Layout

require 'rubygame'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# This is for convenience, so we don't have to go around typing
\end_layout

\begin_layout Plain Layout

# Rubygame:: all the time
\end_layout

\begin_layout Plain Layout

include Rubygame
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# This sets up everything behind the scenes.
  You only have to call it
\end_layout

\begin_layout Plain Layout

# once, at the beginning.
\end_layout

\begin_layout Plain Layout

Rubygame.init()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Now the fun part - creating our game window!
\end_layout

\begin_layout Plain Layout

screen = Screen.new( [640,480] ) # The size of the window we want
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Load a picture
\end_layout

\begin_layout Plain Layout

pic = Surface.load("rubygame.png")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Draw it to the screen
\end_layout

\begin_layout Plain Layout

pic.blit(screen, # Surface to draw on,
\end_layout

\begin_layout Plain Layout

  [0,0])         # and where to draw it
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

# Rubygame needs to know what part of the screen changed in order to re-
\end_layout

\begin_layout Plain Layout

# draw it correctly.
\end_layout

\begin_layout Plain Layout

screen.update(0,0,pic.w, pic.h)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Wait for a bit before exiting
\end_layout

\begin_layout Plain Layout

sleep(5)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Before we exit out altogether, we need to tell Rubygame we're done.
\end_layout

\begin_layout Plain Layout

# This is especially important in fullscreen applications!
\end_layout

\begin_layout Plain Layout

Rubygame.quit()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Running that will display the Rubygame logo in the upper-left corner of
 the window for 5 seconds, and then quit.
\end_layout

\begin_layout Standard
This is pretty much the most bare-bones Rubygame program possible, but every
 Rubygame program operates on the same basic steps:
\end_layout

\begin_layout Enumerate
Require files and initialize Rubygame.
\end_layout

\begin_layout Enumerate
Open a game window
\end_layout

\begin_layout Enumerate
Draw to that window
\end_layout

\begin_layout Enumerate
Process user input
\end_layout

\begin_layout Enumerate
If the game isn't over, go back to step 3.
 Otherwise, shut Rubygame down.
\end_layout

\begin_layout Standard
This bare-bones program demonstrated the first three steps.
 How about the rest?
\end_layout

\begin_layout Subsection
The Game Loop
\end_layout

\begin_layout Standard
A very simple form of processing user input would be to make it so the screen
 sticks around until the user hits a key.
 That turns out to be pretty easy:
\end_layout

\begin_layout Standard
very_first_2.rb
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout

require 'rubygame'
\end_layout

\begin_layout Plain Layout

include Rubygame
\end_layout

\begin_layout Plain Layout

Rubygame.init()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Before we create the screen, we're going to make a list of options
\end_layout

\begin_layout Plain Layout

# we'd like it to have:
\end_layout

\begin_layout Plain Layout

flags = [ HWSURFACE,  # If at all possible, set it up on the video card.
\end_layout

\begin_layout Plain Layout

                      # This is a lot faster than doing it in software.
\end_layout

\begin_layout Plain Layout

	DOUBLEBUF, # If the hardware supports it, enable double buffering
\end_layout

\begin_layout Plain Layout

	FULLSCREEN ] # Use the whole screen!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

screen = Screen.new( [640,480], # The size of the window we want
\end_layout

\begin_layout Plain Layout

  0, # This is the color depth of the screen.
  '0' uses whatever the
\end_layout

\begin_layout Plain Layout

     # default is for the user's screen.
\end_layout

\begin_layout Plain Layout

  flags) # These are the flags we were talking about earlier.
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

pic = Surface.load("rubygame.png")
\end_layout

\begin_layout Plain Layout

# Convert the picture to the default color depth.
  If we don't do this
\end_layout

\begin_layout Plain Layout

# beforehand, it's going to do it anyway right before it draws the
\end_layout

\begin_layout Plain Layout

# image.
  Constant converting like that would slow things down hugely.
\end_layout

\begin_layout Plain Layout

pic = pic.convert()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Everything that happens while the game is running - keys pressed,
\end_layout

\begin_layout Plain Layout

# joysticks moved, mice clicked, etc - comes to us in the form
\end_layout

\begin_layout Plain Layout

# of events.
  We go through them one by one using this queue:
\end_layout

\begin_layout Plain Layout

queue = EventQueue.new()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# A simple flag to indicate we're done.
\end_layout

\begin_layout Plain Layout

finished = false
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# The game loop!
\end_layout

\begin_layout Plain Layout

while not finished
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	# Draw on the screen
\end_layout

\begin_layout Plain Layout

	pic.blit(screen, [0,0])
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	# If the hardware gods were kind to us and we got a hardware surface
\end_layout

\begin_layout Plain Layout

	# with double-buffer support, we can take a shortcut.
  Rather than
\end_layout

\begin_layout Plain Layout

	# tell Rubygame what part of the screen was updated, we can tell it
\end_layout

\begin_layout Plain Layout

	# that the whole screen changed, and to update everything at once:
\end_layout

\begin_layout Plain Layout

	screen.flip()
\end_layout

\begin_layout Plain Layout

	# If we didn't get a hardware surface, this just updates the whole
\end_layout

\begin_layout Plain Layout

	# screen without being fast about it.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	# Process all events that came up this time around.
\end_layout

\begin_layout Plain Layout

	queue.each do | event |
\end_layout

\begin_layout Plain Layout

		case(event)
\end_layout

\begin_layout Plain Layout

		# This event happens whenever someone clicks the 'x' button.
\end_layout

\begin_layout Plain Layout

		# Always respond to this, because it's rude not to.
\end_layout

\begin_layout Plain Layout

		when QuitEvent
\end_layout

\begin_layout Plain Layout

			finished = true
\end_layout

\begin_layout Plain Layout

		# This event happens whenever someone presses a key.
\end_layout

\begin_layout Plain Layout

		when KeyDownEvent
\end_layout

\begin_layout Plain Layout

			# For the purposes of our demo, we're going to quit when this
\end_layout

\begin_layout Plain Layout

			# happens.
\end_layout

\begin_layout Plain Layout

			finished = true
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Rubygame.quit()
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are a number of new concepts:
\end_layout

\begin_layout Subsubsection
Color Depth and Surface Flags
\end_layout

\begin_layout Standard
When I created the screen, this time around, I gave it two extra arguments.
 The first is the 
\series bold
color depth
\series default
 - this indicates how many bits a pixel should take up.
 If you're running this on anything close to a modern computer, this will
 almost always be 32.
 However, you can't count on that always being the case.
 That's why it's a good practice to put '0' in there.
 That will allow the computer to use whatever color depth is the default
 for it.
 
\end_layout

\begin_layout Standard
The second argument was a list of flags.
 These 
\series bold
surface flags
\series default
 are extra information used when setting up the screen.
 We asked for a hardware surface, meaning all our drawing will be done directly
 on the video card.
 We also asked for double buffering support (more on this later) and for
 our display to be full screen.
 Keep in mind that these flags are all requests - depending on the underlying
 hardware support, you may not get everything you ask for.
\end_layout

\begin_layout Subsubsection
Converting Surfaces
\end_layout

\begin_layout Standard
By default, whenever you load something using Surface.load, it's going to
 be in whatever color depth it was on disk.
 So if you load in an 8-bit image, Rubygame is going to have to convert
 it to whatever you're using (likely 32 bits) every time it draws it on
 the screen.
 We explicitly convert it to save a lot of time and effort.
\end_layout

\begin_layout Subsubsection
The Event Queue
\end_layout

\begin_layout Standard
Some game frameworks use polling; with them, if you wanted to know if the
 user was pressing a key, you'd have to constantly call the function that
 asks if a key is being pressed.
 Rubygame works via events - you'll be notified when a key is pressed, and
 then you can check if it's the one you want.
 All these events are put in the queue that we create.
\end_layout

\begin_layout Subsubsection
Double Buffering
\end_layout

\begin_layout Standard
Even if you draw something to the screen, this work is done in a 
\begin_inset Quotes eld
\end_inset

Back Buffer
\begin_inset Quotes erd
\end_inset

 - an area in memory that exists so you can prepare all your changes at
 once.
 The update() call in the first example says 
\begin_inset Quotes eld
\end_inset

This part of the back buffer is ready to be drawn
\begin_inset Quotes erd
\end_inset

.
 If it's done right, just calling update() with the right rectangles can
 be faster than updating the entire screen, but keep in mind that the more
 time you spend tracking what parts of the screen need to be redrawn, the
 less time you're saving.
\end_layout

\begin_layout Standard
Double Buffering simply allows the back buffer and screen to flip places.
 What this means to you is that the entire screen is updated at once and,
 if your hardware supports it, it's done quickly.
 The 'flip' function does all this for you.
 If you didn't end up getting a hardware surface or one that supports double-buf
fering, it falls back on simply updating the entire screen.
\end_layout

\begin_layout Standard
Because it's simple, I'll be using double buffering for the rest of this
 book.
\end_layout

\begin_layout Subsubsection
Event Types
\end_layout

\begin_layout Standard
The first thing we did with our queue was to enable 
\begin_inset Quotes eld
\end_inset

new style
\begin_inset Quotes erd
\end_inset

 events.
 Without this, you'll get entirely different event classes that are deprecated.
 When Rubygame 3 comes out, they'll be gone entirely, so it's a good idea
 to get used to working with the new ones.
 Every event you'll see generated comes from the Rubygame::Events namespace.
\end_layout

\begin_layout Standard
Using a 'case' statement to go through each item in the queue is helpful
 because it'll match on the class of the event, which is likely to determine
 what you do next.
\end_layout

\begin_layout Standard
The 
\series bold
QuitRequested
\series default
 happens when the user indicates they want to quit - they hit the 'x' button,
 or press Alt-F4, or otherwise try to stop the application.
 If you don't respond to this event, your app will keep running.
 This would be the time to do things like quickly save a game or prompt
 for a confirmation, but even then be very careful.
 The user won't appreciate having to kill your program because it doesn't
 appear to be closing right.
\end_layout

\begin_layout Standard
The 
\series bold
KeyDownEvent
\series default
 is exactly what it sounds like: Whenever the user presses a key, this is
 fired.
 Later, we'll use the information in the 'event' variable but for now we
 just quit.
\end_layout

\begin_layout Subsection
Interactivity
\end_layout

\begin_layout Standard
The previous example illustrated a full game loop, but not an interesting
 one.
 Sitting around displaying one image while waiting for the user to press
 a key and then quitting is hardly the pinnacle of game design, after all.
 Let's make it so the user can move the picture around:
\end_layout

\begin_layout Standard
very_first_3.rb
\end_layout

\begin_layout LyX-Code
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout

require 'rubygame'
\end_layout

\begin_layout Plain Layout

include Rubygame
\end_layout

\begin_layout Plain Layout

Rubygame.init()
\end_layout

\begin_layout Plain Layout

# So that we can hold down the button and have it work
\end_layout

\begin_layout Plain Layout

Rubygame.enable_key_repeat(0.5, 0.03)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

flags = [ HWSURFACE, DOUBLEBUF ] 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

screen = Screen.new( [640,480], 0, flags )
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

pic = Surface.load("rubygame.png")
\end_layout

\begin_layout Plain Layout

pic = pic.convert()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

queue = EventQueue.new()
\end_layout

\begin_layout Plain Layout

queue.enable_new_style_events()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

finished = false
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# The location of our picture.
\end_layout

\begin_layout Plain Layout

x = 0
\end_layout

\begin_layout Plain Layout

y = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# How many pixels per second it'll move.
\end_layout

\begin_layout Plain Layout

speed = 100
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# The Clock object helps us move at a constant rate of speed, as we'll
\end_layout

\begin_layout Plain Layout

# see later.
\end_layout

\begin_layout Plain Layout

clock = Clock.new
\end_layout

\begin_layout Plain Layout

# This is also going to become the default in Rubygame 3.0, so we might
\end_layout

\begin_layout Plain Layout

# as well get used to it
\end_layout

\begin_layout Plain Layout

clock.enable_tick_events()
\end_layout

\begin_layout Plain Layout

# The clock lets us enter the amount of FPS we'd like.
  It then slows
\end_layout

\begin_layout Plain Layout

# us down to that number:
\end_layout

\begin_layout Plain Layout

clock.target_framerate = 30
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# The game loop!
\end_layout

\begin_layout Plain Layout

while not finished
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	# This is the number of seconds since last time we were here.
\end_layout

\begin_layout Plain Layout

	# Knowing this number lets us smooth out motion correctly.
\end_layout

\begin_layout Plain Layout

	delay = clock.tick.seconds
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	# Clear the screen first
\end_layout

\begin_layout Plain Layout

	screen.fill( [0,0,0] )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	pic.blit(screen, [x,y])
\end_layout

\begin_layout Plain Layout

	screen.flip()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	queue.each do | event |
\end_layout

\begin_layout Plain Layout

		case(event)
\end_layout

\begin_layout Plain Layout

		when Events::QuitRequested
\end_layout

\begin_layout Plain Layout

			finished = true
\end_layout

\begin_layout Plain Layout

		when Events::KeyPressed
\end_layout

\begin_layout Plain Layout

			# The 'key' field is a symbol
\end_layout

\begin_layout Plain Layout

			if event.key == :up
\end_layout

\begin_layout Plain Layout

				y -= speed * delay
\end_layout

\begin_layout Plain Layout

			elsif event.key == :down
\end_layout

\begin_layout Plain Layout

				y += speed * delay
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

			if event.key == :left
\end_layout

\begin_layout Plain Layout

				x -= speed * delay
\end_layout

\begin_layout Plain Layout

			elsif event.key == :right
\end_layout

\begin_layout Plain Layout

				x += speed * delay
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		when Events::MouseMoved
\end_layout

\begin_layout Plain Layout

			# The 'pos' field is an array of the form [x,y] which
\end_layout

\begin_layout Plain Layout

			# indicates where the mouse event happened.
\end_layout

\begin_layout Plain Layout

			x = event.pos[0]
\end_layout

\begin_layout Plain Layout

			y = event.pos[1]
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Rubygame.quit()
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As before, I've done some new things:
\end_layout

\begin_layout Subsubsection
Key Repeat
\end_layout

\begin_layout Standard
You'll notice that the events we're reacting to when we're moving the image
 around are simple 
\series bold
KeyPressed
\series default
 events.
 We included a line at the very top to enable key repeat.
 That way the user can hold down a button and Rubygame will keep generating
 KeyPressed events for us.
 This isn't the ideal way to handle continuous user input: There's a delay
 between events and so relying on this method will always result in somewhat
 choppy movement.
 I'll show a better way to handle this in section
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Pong"

\end_inset

.
\end_layout

\begin_layout Subsubsection
The Clock
\end_layout

\begin_layout Standard
If you kept an eye on your CPU usage while runing very_first_2.rb, you'll
 probably notice that it spiked enormously.
 It might seem a bit strange that clearing the screen and drawing an image
 should take so much CPU power.
 The fact is, it doesn't, but we didn't introduce any kind of delay or tell
 the operating system we were willing to have it take over for a bit.
 All we did was draw to the screen and look for input in a nonstop tight
 loop.
 It might seem like this is the proper way to work; after all, your game
 will run its fastest if it doesn't bother to wait or put a delay in, but
 keep in mind people aren't going to appreciate having their CPUs entirely
 maxed out running just your game.
\end_layout

\begin_layout Standard
The solution is to put a delay in, and Rubygame offers this in the form
 of the Clock class.
 You tell it how many FPS you'd like to be the maximum, and every time you
 call clock.tick(), it delays so that you meet that FPS goal.
 Obviously it can only do this if you're running faster than the goal.
\end_layout

\begin_layout Standard
The second benefit of the Clock class is that clock.tick returns an object
 that holds the number of seconds since the last time it was called.
 Recall that earlier in the program, we defined the speed of our image in
 pixels per second.
 It'd be hard to actually make it go that speed if we didn't know how many
 seconds had passed!
\end_layout

\begin_layout Subsubsection
Events
\end_layout

\begin_layout Standard
We looked over this briefly in the previous section, but now we're actually
 doing something with our data.
\end_layout

\begin_layout Paragraph
KeyPressed
\end_layout

\begin_layout Standard
We use the 'key' field of this event to determine what to do, and for the
 most part that's what you'll be relying on.
 It's a symbol that corresponds to the key that was pressed.
 So :left is the symbol for the left arrow, :w would be the symbol for the
 'w' key, :f1 is the symbol for F1, and so on.
 For the most part the naming is obvious, but if you want to know the symbol
 for an event there's a fairly simple program that will tell you.
 I've provided it in Appendix 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Key-Symbol-Cheatsheet"

\end_inset

.
\end_layout

\begin_layout Standard
You can tell which modifier keys were held down while the button was pressed
 by looking at the 
\begin_inset Quotes eld
\end_inset

modifiers
\begin_inset Quotes erd
\end_inset

 field, and you can get a printable representation by looking at the contents
 of 
\begin_inset Quotes eld
\end_inset

string
\begin_inset Quotes erd
\end_inset

.
 That way if the user presses shift and 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset

, you don't have to just guess that this is 
\begin_inset Quotes eld
\end_inset

?
\begin_inset Quotes erd
\end_inset

.
 (Especially because that may not be true on other keyboards!)
\end_layout

\begin_layout Paragraph
MouseMoved
\end_layout

\begin_layout Standard
I added this to show a different kind of event.
 MouseMoved tells us that the mouse moved (surprise!).
 We use this to move the image to wherever the mouse currently is.
 The 
\begin_inset Quotes eld
\end_inset

pos
\begin_inset Quotes erd
\end_inset

 field holds the mouse position at the time the event happened.
\end_layout

\begin_layout Subsection
Wrapup
\end_layout

\begin_layout Standard
You officially now have enough knowledge of Rubygame to create a game.
 You can create the screen, draw to it, and respond to user input, and that's
 all you need to know!
\end_layout

\begin_layout Standard
Of course, Rubygame has a great many features which make our life easier.
 The next chapter will have us use everything we just learned as well as
 some new information to create our first full game: That old standby 
\begin_inset Quotes eld
\end_inset

Pong
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Pong
\begin_inset CommandInset label
LatexCommand label
name "sec:Pong"

\end_inset


\end_layout

\begin_layout Standard
Pong was one of the very first video games, dating back to 1972.
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

But,
\begin_inset Quotes erd
\end_inset

 you say, 
\begin_inset Quotes eld
\end_inset

that demo we did in the first section is more sophisticated than that! Why
 are we starting so low-tech?
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
The answer is: Because it's the best way to learn.
 So long as you're doing it for your own learning purposes, re-making old
 games is an excellent way to figure out how things work, because you've
 already got the concept and know how it should turn out.
 All you need to provide is the code and some art, and even programmer art
 ends up better-looking than 1972 Pong!
\end_layout

\begin_layout Subsection
Sprites
\end_layout

\begin_layout Standard
In section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:A-Very-Simple"

\end_inset

's example, we kept track of all the information about our image in variables.
 This works out fine so long as you have a very few images, but what if
 you have more? You don't want to name everything image_1, image_2 or paddle_ima
ge, paddle_x, paddle_y, etc.
 A much easier way to keep track of these things would be in a class:
\end_layout

\begin_layout Standard
simple_class_example.rb
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Paddle
\end_layout

\begin_layout Plain Layout

	attr_accessor :x, :y
\end_layout

\begin_layout Plain Layout

	attr_accessor :speed_x, :speed_y
\end_layout

\begin_layout Plain Layout

	attr_accessor :image
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It turns out that our theoretical Paddle class has a lot in common with
 anything we'd want to draw on the screen - it's got a location and an image,
 for instance.
 We'd probably want to put in a draw() function that paints it to the screen.
 It'd be handy to have a function that'd tell us if it's colliding with
 a ball, as well.
\end_layout

\begin_layout Standard
As it happens, these operations are so common that Rubygame has provided
 a class for them...
 sort of.
 There's a mixin called Rubygame::Sprite that keeps information on where
 a sprite is, as well as how to draw it to the screen.
 You include it in your own objects in order to use its functionality.
 Here's an initial look at the Paddle class using Rubygame::Sprite:
\end_layout

\begin_layout Standard
paddle.rb
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'rubygame'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

include Rubygame
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Paddle
\end_layout

\begin_layout Plain Layout

	include Sprites::Sprite
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	# Sprite already has an 'image' accessor for us, as well
\end_layout

\begin_layout Plain Layout

	# as a 'rect' accessor that determines where the sprite is
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	# It doesn't give us a speed, though, so we're going to have
\end_layout

\begin_layout Plain Layout

	# to provide that ourselves
\end_layout

\begin_layout Plain Layout

	attr_accessor :speed
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def initialize(filename)
\end_layout

\begin_layout Plain Layout

		# If you use the default draw function that the Sprite
\end_layout

\begin_layout Plain Layout

		# mixin provides (and we are in this example), then you
\end_layout

\begin_layout Plain Layout

		# need to have an @image variable
\end_layout

\begin_layout Plain Layout

		@image = Surface.load(filename).convert()
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		# This is a Rubygame Rectangle, and it provides us with all
\end_layout

\begin_layout Plain Layout

		# kinds of useful functionality.
  Like @image, it's required
\end_layout

\begin_layout Plain Layout

		# for the Sprite mixin.
\end_layout

\begin_layout Plain Layout

		@rect = Rect.new(0,0,@image.w, @image.h)
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@speed = 100
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let's see it in action - here's the very beginning of our pong program:
\end_layout

\begin_layout Standard
pong.rb
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'rubygame'
\end_layout

\begin_layout Plain Layout

require 'paddle'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

include Rubygame
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def main()
\end_layout

\begin_layout Plain Layout

	Rubygame.init()
\end_layout

\begin_layout Plain Layout

	flags = [HWSURFACE, DOUBLEBUF]
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	screen = Screen.new( [640,480], 0, flags)
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	clock = Clock.new
\end_layout

\begin_layout Plain Layout

	clock.enable_tick_events()
\end_layout

\begin_layout Plain Layout

	clock.target_framerate = 30
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	queue = EventQueue.new()
\end_layout

\begin_layout Plain Layout

	queue.enable_new_style_events()
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	# Here's where we create our new paddle object, rather
\end_layout

\begin_layout Plain Layout

	# than use a bunch of separate variables for the task
\end_layout

\begin_layout Plain Layout

	paddle = Paddle.new("paddle.png")
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	finished = false
\end_layout

\begin_layout Plain Layout

	while not finished
\end_layout

\begin_layout Plain Layout

		delay = clock.tick.seconds
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		screen.fill( [0, 0, 0] )
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		paddle.draw(screen)
\end_layout

\begin_layout Plain Layout

		screen.flip()
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		queue.each do |event|
\end_layout

\begin_layout Plain Layout

			case(event)
\end_layout

\begin_layout Plain Layout

			when Events::QuitRequested
\end_layout

\begin_layout Plain Layout

				finished = true
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if __FILE__ == $0
\end_layout

\begin_layout Plain Layout

	main()
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If anything, this has less functionality than the previous demo - we've
 gone back to simply displaying an image on the screen.
 A very ugly image, for that matter! But we did cover some important areas
 getting to this point, and it's starting to look less like a simple demo
 and more like a proper game.
 Here's what's new:
\end_layout

\begin_layout Subsubsection
The Sprite Mixin
\end_layout

\begin_layout Standard
As mentioned in the code, including the sprite only requires you do two
 things: First, provide an @image variable with the Surface that will be
 drawn, and second, provide a @rect variable to represent where this image
 is on screen.
 You'll notice that we call Paddle.draw(screen) in the main 'pong.rb' file
 but haven't defined it anywhere - that's because the Sprite mixin has provided
 that code for us.
 It's the same code as we used in the first example (using Surface.blit)
 but since it's already been written for us, let's not reinvent the wheel!
\end_layout

\begin_layout Subsubsection
The Paddle Object
\end_layout

\begin_layout Standard
This isn't exactly a new Rubygame concept, given that we created it ourselves
 up there, but it is an important one.
 Separating our game objects out of the main loop is one step toward a more
 object-oriented approach, and that's one that makes it easier to change
 things later.
 For similar reasons, this is also why we put the Paddle code in its own
 file.
 For now, we're not doing much else in the way of separation, but keep it
 in mind as we go along.
\end_layout

\begin_layout Subsubsection
This is boring!
\end_layout

\begin_layout Standard
That's a good point: Let's put some interactivity into our paddle.
 Add this to the initialize function in the Paddle class in paddle.rb:
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@keys = {}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And then add these functions to the class:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def key(sym, pressed)
\end_layout

\begin_layout Plain Layout

		@keys[sym] = pressed
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def move(dx, dy)
\end_layout

\begin_layout Plain Layout

		@rect.move!(dx,dy)
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		amount = delay * @speed
\end_layout

\begin_layout Plain Layout

		if @keys[:up]
\end_layout

\begin_layout Plain Layout

			move(0,-amount)
\end_layout

\begin_layout Plain Layout

		elsif @keys[:down]
\end_layout

\begin_layout Plain Layout

			move(0, amount)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if @keys[:left]
\end_layout

\begin_layout Plain Layout

			move(-amount, 0)
\end_layout

\begin_layout Plain Layout

		elsif @keys[:right]
\end_layout

\begin_layout Plain Layout

			move(amount, 0)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The update function should look a little familiar - it's very similar to
 the one we used in our first demo.
 Instead of checking event types and then keys, though, we're referring
 to a dictionary of keys.
 This dictionary is in the form of :key => boolean, where :key is the key
 in question, and the boolean is whether it's currently pressed or not.
 We create this dictionary in initialize() and keep it up to date in the
 key() function.
 But if you ran this right now, you'd notice that nothing's happening.
 That's for two reasons: One, the key() function isn't being called.
 Two, even if it was, update() is also not being called! 
\end_layout

\begin_layout Standard
Let's make some changes to pong.rb to fix that.
 Change your queue loop to look like this:
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		queue.each do |event|
\end_layout

\begin_layout Plain Layout

			case(event)
\end_layout

\begin_layout Plain Layout

			when Events::QuitRequested
\end_layout

\begin_layout Plain Layout

				finished = true
\end_layout

\begin_layout Plain Layout

			when Events::KeyPressed
\end_layout

\begin_layout Plain Layout

				paddle.key(event.key, true)
\end_layout

\begin_layout Plain Layout

			when Events::KeyReleased
\end_layout

\begin_layout Plain Layout

				paddle.key(event.key, false)
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		paddle.update(delay)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now if you run that, you'll be able to move the image of the paddle all
 around the screen.
\end_layout

\begin_layout Subsubsection
But what exactly is happening there?
\end_layout

\begin_layout Standard
We're actually doing the same thing we were doing in the first demo, it's
 just somewhat removed from the internals now.
 Here's an outline of what our game loop is like and how it's interacting
 with paddle.rb:
\end_layout

\begin_layout Enumerate
paddle.draw(screen) is called - this calls the sprite mixin that we included
 in paddle.rb, which draws the @image variable to the screen at the @rect
 location.
\end_layout

\begin_layout Enumerate
If we get any key events - either pressed or released - we call the 'key'
 function that sets up a :key => pressed/released relation in a dictionary.
\end_layout

\begin_layout Enumerate
We call update(delay) on our paddle.
 That's when it looks at the dictionary and sees if any of the keys it's
 interested in are pressed.
 If so, it moves the paddle.
\end_layout

\begin_layout Standard
If you've paid very close attention to the differences between this and
 the last demo, you'll notice there was a part of the setup we didn't do:
 We never called enable_key_repeat.
 But if you've ran the above, you've seen that the paddle moves around the
 screen smoothly as long as you hold the button down.
 What gives?
\end_layout

\begin_layout Subsubsection
Smooth Moves
\end_layout

\begin_layout Standard
The first demo moved things by reacting explicitly to the key press and
 nothing else.
 The key press events are (normally) only generated once, when you press
 the key.
 The enable_key_repeat function changes that, by feeding a stream of KeyPressed
 events so long as you're holding the button down.
 As mentioned before, this works for the most part but isn't ideal - it
 can result in somewhat jerky behavior and creates an awful lot of event
 objects.
\end_layout

\begin_layout Standard
We get around that by storing the current state of the key in the paddle.
 Any time we get an event, we update that state, but otherwise we don't
 do any further processing.
 Later, when we call update(delay), we check the current state of the key
 to determine what to do.
 Since we call that update function about 30 times a second and we only
 change the state in response to the user doing something, we end up with
 smooth movement.
\end_layout

\begin_layout Subsubsection
Constraints
\end_layout

\begin_layout Standard
You probably noticed something about the behavior of the paddle, and also
 the rubygame logo from the first demo: You can easily move them off the
 screen.
 Obviously, this is not something we want to allow! Furthermore, it'd be
 a bit like cheating if we left in the player's ability to move horizontally.
 Change paddle.rb's update function to look like this:
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		amount = delay * @speed
\end_layout

\begin_layout Plain Layout

		if @keys[:up]
\end_layout

\begin_layout Plain Layout

			move(0,-amount)
\end_layout

\begin_layout Plain Layout

		elsif @keys[:down]
\end_layout

\begin_layout Plain Layout

			move(0, amount)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		# As long as the screen's been created, you can get it
\end_layout

\begin_layout Plain Layout

		# from anywhere in the program using this
\end_layout

\begin_layout Plain Layout

		screen = Screen.get_surface()
\end_layout

\begin_layout Plain Layout

		if @rect.top < 0
\end_layout

\begin_layout Plain Layout

			@rect.top = 0
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		if @rect.bottom > screen.h
\end_layout

\begin_layout Plain Layout

			@rect.bottom = screen.h
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Rectangle methods
\end_layout

\begin_layout Standard
We haven't done much with the @rect object besides set it up in the first
 place and then move it around.
 It turns out that Rubygame::Rect has a large number of functions that can
 prove very useful.
 You can both get and set the top and bottom (and left and right, for that
 matter), rather than adding the y location to the height and doing the
 math yourself.
\end_layout

\begin_layout Subsubsection
The Screen
\end_layout

\begin_layout Standard
Screen.get_surface() will give you the screen, so long as it's been created,
 anywhere in your program.
 Be careful with it, though, as if you call it before you've actually created
 the screen, it'll error out.
\end_layout

\begin_layout Subsubsection
Okay, so why is the paddle so ugly?
\end_layout

\begin_layout Standard
Because I'm a horrible artist.
\end_layout

\begin_layout Standard
But that's probably not what you're referring to.
 Rather, you're wondering what the garish magenta box outline around the
 paddle is all about.
 It comes down to background colors.
 Because we want a rounded paddle but all images are loaded as squares,
 we've got a portion of the image that's just background.
 Now, you could take the easy way out and change that magenta to black,
 and everything would look fine.
 Later, though, if you wanted to change your background color to something
 else you'd have to go through every image and re-paint its background.
\end_layout

\begin_layout Standard
Imagine that, instead, you could just tell Rubygame that you want a certain
 color to be treated as transparent.
 Now, you could choose black or white but chances are good that those colors
 are going to be in an image eventually.
 Thus, we chose magenta.
 Full red, no green, full blue - it's a horrible eye-catching color that
 will, if we live fortunate lives, never occur in our images naturally.
\end_layout

\begin_layout Standard
So, once we've picked a color, how do we tell Rubygame to use it as a background
? Change your initialize() for the Paddle class to be this:
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def initialize(filename)
\end_layout

\begin_layout Plain Layout

		# If you use the default draw function that the Sprite
\end_layout

\begin_layout Plain Layout

		# mixin provides (and we are in this example), then you
\end_layout

\begin_layout Plain Layout

		# need to have an @image variable
\end_layout

\begin_layout Plain Layout

		@image = Surface.load(filename).convert()
\end_layout

\begin_layout Plain Layout

		@image.colorkey = [255, 0, 255]
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		# This is a Rubygame Rectangle, and it provides us with all
\end_layout

\begin_layout Plain Layout

		# kinds of useful functionality.
  Like @image, it's required
\end_layout

\begin_layout Plain Layout

		# for the Sprite mixin.
\end_layout

\begin_layout Plain Layout

		@rect = Rect.new(0,0,@image.w, @image.h)
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@speed = 100
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		# This will eventually hold the state of the entire keyboard
\end_layout

\begin_layout Plain Layout

		@keys = {}
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The colorkey accessor controls which color (if any) should be treated as
 the background color and not painted.
 You specify the color the same way we did when we cleared the screen, in
 [red,green,blue] and on a scale of 0-255.
 Once that's done, run and see the (slightly) more beautiful paddle.
\end_layout

\begin_layout Subsection
Moving on its own
\end_layout

\begin_layout Standard
Our paddle is more or less in good enough shape.
 Let's make the thing we're supposed to be batting around - the ball:
\end_layout

\begin_layout Standard
ball.rb
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'rubygame'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

include Rubygame
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Ball
\end_layout

\begin_layout Plain Layout

	include Sprites::Sprite
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def initialize(filename)
\end_layout

\begin_layout Plain Layout

		@image = Surface.load(filename).convert()
\end_layout

\begin_layout Plain Layout

		@image.colorkey = [255,0,255]
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@rect = Rect.new(0,0,@image.w, @image.h)
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		reset
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def reset
\end_layout

\begin_layout Plain Layout

		screen = Screen.get_surface()
\end_layout

\begin_layout Plain Layout

		@rect.center = [screen.w/2, screen.h / 2]
\end_layout

\begin_layout Plain Layout

		@direction = [-1.0, -1.0]
\end_layout

\begin_layout Plain Layout

		@speed = 150
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		amount = delay * @speed
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@rect.x += @direction[0] * amount;
\end_layout

\begin_layout Plain Layout

		@rect.y += @direction[1] * amount;
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You'll probably notice that the initialize() routine is almost exactly the
 same as the paddle's.
 In the future we'll be taking advantage of this fact and making our own
 classes to handle it, but for now we'll have to deal with duplicated code.
\end_layout

\begin_layout Standard
What's new?
\end_layout

\begin_layout Subsubsection
Reset
\end_layout

\begin_layout Standard
About half of the initialization is actually done in the reset() function.
 The reason for this is that the function puts the ball back in the middle
 of the screen and sets its initial direction and speed.
 We want that in its own function so we can call it later (such as when
 one of the players scores a point) and not just at the beginning when it's
 created
\end_layout

\begin_layout Subsubsection
Update
\end_layout

\begin_layout Standard
The update should look a little bit familiar - I'm doing the same scaling
 technique I did with the paddle in order to keep it moving at a smooth
 150 pixels per second (or whatever its @speed happens to be at the time).
 After that, though, note that I'm not taking any user input.
 This is intentional - the only influence the player should have over the
 ball is bouncing it against the paddle.
 Instead, its 'x' location is increased by the first part of its direction,
 and its 'y' location is increased by the second part.
 We're keeping the 'direction' as a simple array because all we really want
 to know is:
\end_layout

\begin_layout Description
Is
\begin_inset space ~
\end_inset

it
\begin_inset space ~
\end_inset

traveling
\begin_inset space ~
\end_inset

left
\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset

right? If so, the first item in @direction will be -1 for left or 1 for
 right, and
\end_layout

\begin_layout Description
Is
\begin_inset space ~
\end_inset

it
\begin_inset space ~
\end_inset

traveling
\begin_inset space ~
\end_inset

up
\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset

down? Similarly, the second item in @direction will be -1 for up or 1 for
 down.
\end_layout

\begin_layout Subsubsection
Adding the ball to the field
\end_layout

\begin_layout Standard
Running the game right now will have no effect, because we don't actually
 use our ball object anywhere.
 So open up 'pong.rb' and add the following line to the top after the other
 'require' statements:
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'ball'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then rewrite the game loop as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	paddle = Paddle.new("paddle.png")
\end_layout

\begin_layout Plain Layout

	ball = Ball.new("ball.png")
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	finished = false
\end_layout

\begin_layout Plain Layout

	while not finished
\end_layout

\begin_layout Plain Layout

		delay = clock.tick.seconds
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		screen.fill( [0, 0, 0] )
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		paddle.draw(screen)
\end_layout

\begin_layout Plain Layout

		ball.draw(screen)
\end_layout

\begin_layout Plain Layout

		screen.flip()
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		queue.each do |event|
\end_layout

\begin_layout Plain Layout

			case(event)
\end_layout

\begin_layout Plain Layout

			when Events::QuitRequested
\end_layout

\begin_layout Plain Layout

				finished = true
\end_layout

\begin_layout Plain Layout

			when Events::KeyPressed
\end_layout

\begin_layout Plain Layout

				paddle.key(event.key, true)
\end_layout

\begin_layout Plain Layout

			when Events::KeyReleased
\end_layout

\begin_layout Plain Layout

				paddle.key(event.key, false)
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		paddle.update(delay)
\end_layout

\begin_layout Plain Layout

		ball.update(delay)
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you run this, you'll be able to behold the wonder of the ball moving
 all on its own...
 right off the screen!
\end_layout

\begin_layout Subsubsection
Constraints, part 2
\end_layout

\begin_layout Standard
Naturally this is going to be a very hard game of pong if the ball won't
 stay on the screen.
 Let's add a function to ball.rb:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def check_collision
\end_layout

\begin_layout Plain Layout

		screen = Screen.get_surface()
\end_layout

\begin_layout Plain Layout

		if(@rect.top <= 0 or @rect.bottom > screen.h)
\end_layout

\begin_layout Plain Layout

			@direction[1] = -@direction[1]
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if(@rect.left <= 0 or @rect.right >= screen.w)
\end_layout

\begin_layout Plain Layout

			@direction[0] = - @direction[0]
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And make sure it's called in the update:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		amount = delay * @speed
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@rect.x += @direction[0] * amount;
\end_layout

\begin_layout Plain Layout

		@rect.y += @direction[1] * amount;
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		check_collision
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Running this gives us a slightly better result, in that the ball now bounces
 around the screen.
 It doesn't bounce off of the player's paddle, though.
\end_layout

\begin_layout Standard
There are a few ways to handle this sort of collision detection:
\end_layout

\begin_layout Description
Just
\begin_inset space ~
\end_inset

hack
\begin_inset space ~
\end_inset

it
\begin_inset space ~
\end_inset

together: We could put a function in our game loop that checks to see if
 the ball is colliding with the paddle and, if so, bounce it appropriately.
 This would work for our example, but remember we're going to be shortly
 adding another paddle.
 Any more objects and it'd get really complicated, really quickly.
\end_layout

\begin_layout Description
Dedicated
\begin_inset space ~
\end_inset

collision
\begin_inset space ~
\end_inset

manager: If we had an object whose job it was to keep track of all the sprites
 on screen and test them against each other for collisions, we could put
 all our testing logic in there.
 That way we could add as many objects as we wanted and still have it work.
 Overall, this is one of the better solutions (and one we'll be examining
 later) but it requires that you've planned out your objects and how you
 want them to interact.
 They need to be general enough for a manager to be able to deal with them
 en masse, and we haven't done that yet.
 That leaves a third option:
\end_layout

\begin_layout Description
Let
\begin_inset space ~
\end_inset

the
\begin_inset space ~
\end_inset

objects
\begin_inset space ~
\end_inset

handle
\begin_inset space ~
\end_inset

it: Specifically, we can tell the ball what sprites to look for, and it'll
 check for collisions with them.
 This is also a good solution if you know what objects you're going to be
 potentially colliding with beforehand.
 In our case, we do, so this is the approach we'll take for this example.
\end_layout

\begin_layout Standard
We need to rewrite our ball's constructor to take in the paddles it'll be
 colliding with.
 Change ball.rb's initialize to the following:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def initialize(filename, paddles)
\end_layout

\begin_layout Plain Layout

		@image = Surface.load(filename).convert()
\end_layout

\begin_layout Plain Layout

		@image.colorkey = [255,0,255]
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@rect = Rect.new(0,0,@image.w, @image.h)
\end_layout

\begin_layout Plain Layout

		@paddles = paddles
\end_layout

\begin_layout Plain Layout

		reset
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I'm going to do a little rewriting of our check_collision function, and
 I'm adding a new function called bounce():
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def bounce(index)
\end_layout

\begin_layout Plain Layout

		@direction[index] = -@direction[index]
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def check_collision
\end_layout

\begin_layout Plain Layout

		screen = Screen.get_surface()
\end_layout

\begin_layout Plain Layout

		if(@rect.top <= 0 or @rect.bottom > screen.h)
\end_layout

\begin_layout Plain Layout

			bounce(1)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if(@rect.left <= 0 or @rect.right >= screen.w)
\end_layout

\begin_layout Plain Layout

			bounce(0)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@paddles.each do |paddle|
\end_layout

\begin_layout Plain Layout

			if collide_sprite?(paddle)
\end_layout

\begin_layout Plain Layout

				bounce(0)
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Two new things here:
\end_layout

\begin_layout Subsubsection
Bounce
\end_layout

\begin_layout Standard
The bounce() function takes an index into the 'direction' array and negates
 whatever's there.
 If the index is 0, it changes from right to left or vice versa.
 If it's one, it changes the up/down direction.
 It's basically doing the same thing the old code was doing, only now the
 part that actually changes the direction is on its own.
 This is helpful if we want to do something every time the ball bounces
 (which we will, later).
\end_layout

\begin_layout Subsubsection
collide_sprite?
\end_layout

\begin_layout Standard
This is another gift that the Sprite mixin has given us.
 It takes the rectangle of the current sprite and checks to see if it collides
 with the rectangle of the given sprite.
 If so, we call our 'bounce' function.
\end_layout

\begin_layout Standard
This is a very simple way to do collision detection, and also somewhat wrong.
 We wait until we've already moved the ball to see if it's colliding with
 anything, and only then do we change its direction.
 If the ball or the player is moving fast, it's possible that the direction
 change won't be enough to push the ball away, in which case it'll change
 direction again (because it's still colliding).
 To the player, it'll look like the ball is stuck in the paddle! Fortunately,
 it's unlikely that the player is actually going to move that quickly, so
 in this case we won't take any additional measures.
 We'll address ways to deal with the problem in future projects.
\end_layout

\begin_layout Subsubsection
It doesn't work
\end_layout

\begin_layout Standard
Trying to run our program now will fail, because while we changed the constructo
r for Ball, we never actually changed how we're calling it.
 Go back to pong.rb and change the line that creates the Ball to:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ball = Ball.new("ball.png", [paddle])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Yep, we're passing in an array of one paddle, but that'll change once we
 create another one.
 Run the game and enjoy playing a solitaire version of pong that you can't
 lose.
 At least the ball bounces off your paddle now!
\end_layout

\begin_layout Subsection
Your opponent
\end_layout

\begin_layout Standard
Okay, solitaire is boring, let's add in that other paddle.
 Change your game loop in pong.rb to look like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	paddle = Paddle.new("paddle.png")
\end_layout

\begin_layout Plain Layout

	paddle2 = Paddle.new("paddle.png")
\end_layout

\begin_layout Plain Layout

	paddle2.rect.right = screen.w
\end_layout

\begin_layout Plain Layout

	ball = Ball.new("ball.png", [paddle,paddle2])
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	finished = false
\end_layout

\begin_layout Plain Layout

	while not finished
\end_layout

\begin_layout Plain Layout

		delay = clock.tick.seconds
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		screen.fill( [0, 0, 0] )
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		paddle.draw(screen)
\end_layout

\begin_layout Plain Layout

		paddle2.draw(screen)
\end_layout

\begin_layout Plain Layout

		ball.draw(screen)
\end_layout

\begin_layout Plain Layout

		screen.flip()
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		queue.each do |event|
\end_layout

\begin_layout Plain Layout

			case(event)
\end_layout

\begin_layout Plain Layout

			when Events::QuitRequested
\end_layout

\begin_layout Plain Layout

				finished = true
\end_layout

\begin_layout Plain Layout

			when Events::KeyPressed
\end_layout

\begin_layout Plain Layout

				paddle.key(event.key, true)
\end_layout

\begin_layout Plain Layout

			when Events::KeyReleased
\end_layout

\begin_layout Plain Layout

				paddle.key(event.key, false)
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		paddle.update(delay)
\end_layout

\begin_layout Plain Layout

		paddle2.update(delay)
\end_layout

\begin_layout Plain Layout

		ball.update(delay)
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That snippet of code is getting bigger and bigger, but really all we did
 was add the new paddle, put it over to the right side of the screen, and
 make sure it was getting drawn.
 If you run this, you'll see a two-player pong setup but the right paddle
 will never move.
 We have two ways of doing that:
\end_layout

\begin_layout Description
Add
\begin_inset space ~
\end_inset

more
\begin_inset space ~
\end_inset

controls: The paddle currently looks for the 'up' and 'down' keys to control
 its movement.
 We could change it so that it'd know if it was player1 or player2 and look
 for 'a' and 'z' if it was player 1.
 We'd have to add paddle2.key() calls to the game loop, but it'd be pretty
 simple and is essentially a rehash of what we've already done.
 That's why we're going with option #2:
\end_layout

\begin_layout Description
Have
\begin_inset space ~
\end_inset

the
\begin_inset space ~
\end_inset

computer
\begin_inset space ~
\end_inset

take
\begin_inset space ~
\end_inset

over: We can create a subclass of Paddle that doesn't rely on user input.
 Like the ball, it'll do its own thing.
 In this case, it'll try to move itself as close to the ball as it can.
\end_layout

\begin_layout Standard
We're subclassing paddle rather than creating an entirely new sprite class
 because the only difference is how their update() function works.
 And as you'll see, it's not really that different at all.
 Add this to the bottom of your paddle.rb:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class AIPaddle < Paddle
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	attr_accessor :ball
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		if @ball
\end_layout

\begin_layout Plain Layout

			@keys[:up] = @ball.rect.centery < @rect.centery - 10
\end_layout

\begin_layout Plain Layout

			@keys[:down] = @ball.rect.centery > @rect.centery + 10
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		super(delay)
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That's really all you need.
 If the ball's center is above where the paddle is, it'll move up (by pretending
 its user pushed its 'up' button) and if the ball's center is below, it'll
 move down.
 I put the extra 10 pixels in there so it's not perfect and it isn't moving
 all the time.
\end_layout

\begin_layout Standard
It's easy to see this in action, go back to pong.rb and change the paddle
 setup to:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	paddle = Paddle.new("paddle.png")
\end_layout

\begin_layout Plain Layout

	paddle2 = AIPaddle.new("paddle.png")
\end_layout

\begin_layout Plain Layout

	paddle2.rect.right = screen.w
\end_layout

\begin_layout Plain Layout

	ball = Ball.new("ball.png", [paddle,paddle2])
\end_layout

\begin_layout Plain Layout

	paddle2.ball = ball
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Besides changing Paddle to AIPaddle in the case of paddle2, we also had
 to add a line telling paddle2 where its ball is.
 Otherwise it wouldn't know where to move!
\end_layout

\begin_layout Standard
Run the game and enjoy playing against a flawless opponent in a game you
 can't win or lose.
 Obviously, we're going to have to put some kind of scoring system in if
 we want this game to go anywhere.
\end_layout

\begin_layout Subsection
Text
\end_layout

\begin_layout Standard
Rubygame offers support for two kinds of fonts: SFont and TTF.
 SFont is a bitmap font in use primarily in some linux games and libraries,
 while TTF is in wide use by both linux and windows systems.
 Given TTF's relative ubiquity and the ease of finding new fonts for it,
 this book will concentrate on the latter.
\end_layout

\begin_layout Standard
We'll be using the free Bitstream Vera font from the GNOME collection throughout
 the book - it's included in this book's accompanying source code and is
 available under a very liberal license (essentially, you can use it in
 whatever games you want).
\end_layout

\begin_layout Standard
The first part of using the TTF library is setting it up - like Rubygame,
 it also needs to have a setup function called before it can be used.
 So back in pong.rb, add this to the beginning of main():
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def main()
\end_layout

\begin_layout Plain Layout

	Rubygame.init()
\end_layout

\begin_layout Plain Layout

	Rubygame::TTF.setup()
\end_layout

\begin_layout Plain Layout

	flags = [HWSURFACE, DOUBLEBUF]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next, we're going to use what we can from our sprite mixin.
 Because a TTF can't just be drawn like an ordinary image, we have to get
 a bit fancy.
 Here's what score.rb looks like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'rubygame'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

include Rubygame
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Scoreboard
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	include Sprites::Sprite
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	attr_reader :score
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def initialize(filename, initial_score = 0)
\end_layout

\begin_layout Plain Layout

		@font = TTF.new(filename, 18)
\end_layout

\begin_layout Plain Layout

		@rect = Rect.new(0,0,0,0)
\end_layout

\begin_layout Plain Layout

		self.score = initial_score
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def score=(new_score)
\end_layout

\begin_layout Plain Layout

		@score = new_score
\end_layout

\begin_layout Plain Layout

		@image = @font.render(
\end_layout

\begin_layout Plain Layout

			@score.to_s,     # The text to render
\end_layout

\begin_layout Plain Layout

			true,            # Do we want antialiasing?
\end_layout

\begin_layout Plain Layout

			[255,255,255])   # The color of the text
\end_layout

\begin_layout Plain Layout

		@rect.w = @image.w
\end_layout

\begin_layout Plain Layout

		@rect.h = @image.h
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This one has a filename like the ones that made images, but unlike them
 we use it to load a TTF.
 The next thing we do is to create a rectangle with no width or height.
 Again, unlike the images we can't know what size this will be until we
 try to draw a string using it.
 Next, we use the 'score=' function to do exactly that.
\end_layout

\begin_layout Subsubsection
Rendering text
\end_layout

\begin_layout Standard
You can't directly blit a font to the screen like you can with an image.
 Instead, the TTF.render() function creates a Surface, and you can use that.
 We opt to do this once, when the score changes, rather than every frame,
 which would get a bit slow.
 Once we've actually put the text onto a surface, we can then measure that
 surface and set our @rect accordingly.
\end_layout

\begin_layout Subsubsection
Adding more objects
\end_layout

\begin_layout Standard
The game loop is getting incredibly crowded at this point! pong.rb's loop
 should look like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	paddle = Paddle.new("paddle.png")
\end_layout

\begin_layout Plain Layout

	paddle2 = AIPaddle.new("paddle.png")
\end_layout

\begin_layout Plain Layout

	paddle2.rect.right = screen.w
\end_layout

\begin_layout Plain Layout

	ball = Ball.new("ball.png", [paddle,paddle2])
\end_layout

\begin_layout Plain Layout

	paddle2.ball = ball
\end_layout

\begin_layout Plain Layout

	scores = [
\end_layout

\begin_layout Plain Layout

		Scoreboard.new("VeraMoBd.ttf"),
\end_layout

\begin_layout Plain Layout

		Scoreboard.new("VeraMoBd.ttf")
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

	scores[0].rect.x = 60
\end_layout

\begin_layout Plain Layout

	scores[1].rect.right = screen.w - 60
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	finished = false
\end_layout

\begin_layout Plain Layout

	while not finished
\end_layout

\begin_layout Plain Layout

		delay = clock.tick.seconds
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		screen.fill( [0, 0, 0] )
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		paddle.draw(screen)
\end_layout

\begin_layout Plain Layout

		paddle2.draw(screen)
\end_layout

\begin_layout Plain Layout

		ball.draw(screen)
\end_layout

\begin_layout Plain Layout

		scores.each do |board|
\end_layout

\begin_layout Plain Layout

			board.draw(screen)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		screen.flip()
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		queue.each do |event|
\end_layout

\begin_layout Plain Layout

			case(event)
\end_layout

\begin_layout Plain Layout

			when Events::QuitRequested
\end_layout

\begin_layout Plain Layout

				finished = true
\end_layout

\begin_layout Plain Layout

			when Events::KeyPressed
\end_layout

\begin_layout Plain Layout

				paddle.key(event.key, true)
\end_layout

\begin_layout Plain Layout

			when Events::KeyReleased
\end_layout

\begin_layout Plain Layout

				paddle.key(event.key, false)
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		paddle.update(delay)
\end_layout

\begin_layout Plain Layout

		paddle2.update(delay)
\end_layout

\begin_layout Plain Layout

		ball.update(delay)
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Again, a lot of text for relatively few changes.
 We created the scoreboards in an array and then later painted them to the
 screen.
 Note that we don't call update() on them, as they are only going to change
 when the score changes.
 Speaking of which, when is that happening?
\end_layout

\begin_layout Subsection
Callbacks
\end_layout

\begin_layout Standard
The check_collision function of the Ball object already knows if we've gone
 off either side of the screen, so it would seem the logical place to change
 the score would be there.
 There's only one problem: The ball doesn't know anything about the scoreboard.
\end_layout

\begin_layout Standard
As before, there are a few ways to handle this.
 We could do the same thing we did with the paddles and explicitly pass
 the scoreboards in, but this even further tightly couples the ball to the
 rest of the objects in the game.
 The more things we add to the ball object, the more complicated it gets
 and the more variables we need to keep track of.
 We don't want it to look like the game loop up there, after all!
\end_layout

\begin_layout Standard
Another way to handle this is via a callback.
 Essentially, we write a function that handles scoring, and we tell the
 Ball object to call that function when the subject comes up.
 Here's how we'll use it in pong.rb:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	scores = [
\end_layout

\begin_layout Plain Layout

		Scoreboard.new("VeraMoBd.ttf"),
\end_layout

\begin_layout Plain Layout

		Scoreboard.new("VeraMoBd.ttf")
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

	scores[0].rect.x = 60
\end_layout

\begin_layout Plain Layout

	scores[1].rect.right = screen.w - 60
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	ball.when_score do |index|
\end_layout

\begin_layout Plain Layout

		scores[index].score += 1
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pretty simple, really, at least from this side of the equation.
 Of course, running this will fail miserably because we haven't written
 the when_score function yet.
 Go over to ball.rb and add these two functions:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def announce_score(index)
\end_layout

\begin_layout Plain Layout

		if @score_callback
\end_layout

\begin_layout Plain Layout

			@score_callback.call(index)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def when_score(&block)
\end_layout

\begin_layout Plain Layout

		@score_callback = block
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This will make the game run, but points still aren't scored.
 That's because we need to change the way check_collision works:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def check_collision
\end_layout

\begin_layout Plain Layout

		screen = Screen.get_surface()
\end_layout

\begin_layout Plain Layout

		if(@rect.top <= 0 or @rect.bottom > screen.h)
\end_layout

\begin_layout Plain Layout

			bounce(1)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if(@rect.left <= 0)
\end_layout

\begin_layout Plain Layout

			announce_score(1)
\end_layout

\begin_layout Plain Layout

			reset
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		if(@rect.right >= screen.w)
\end_layout

\begin_layout Plain Layout

			announce_score(0)
\end_layout

\begin_layout Plain Layout

			reset
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@paddles.each do |paddle|
\end_layout

\begin_layout Plain Layout

			if collide_sprite?(paddle)
\end_layout

\begin_layout Plain Layout

				bounce(0)
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So, flow of scoring goes as follows:
\end_layout

\begin_layout Enumerate
At the beginning of the game, we call when_score with a block of code that
 adds '1' to whichever side scored.
 Because calling score= on the Scoreboard object causes it to re-draw its
 image, that one line of code is all we have to do to update the score.
\end_layout

\begin_layout Enumerate
Later, when the ball goes off the edge, the check_collision function figures
 out who let it through, and announces that the other side should get a
 point
\end_layout

\begin_layout Enumerate
The announce_score function calls the block of code that was set aside earlier
 and informs it of the side that scored.
\end_layout

\begin_layout Standard
Callbacks are a very powerful way to de-couple your objects.
 Notice that the Ball didn't need to know anything about the Scoreboards
 or how they worked.
 We could replace the scoreboards with smilie-face sprites that light up
 depending on how high your score is, and we wouldn't have to change a single
 line of code in ball.rb to deal with it.
\end_layout

\begin_layout Subsection
Winning and Losing
\end_layout

\begin_layout Standard
This game is...
 boring.
 The computer still plays a flawless game and the ball moves slowly enough
 that it's probably pretty easy for you to keep it going.
 We need some challenge.
 Remember earlier when I made ball.rb's 
\begin_inset Quotes eld
\end_inset

bounce
\begin_inset Quotes erd
\end_inset

 functionality into a separate function? Change it as follows and you'll
 see why:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def bounce(index)
\end_layout

\begin_layout Plain Layout

		@direction[index] = -@direction[index]
\end_layout

\begin_layout Plain Layout

		@speed *= 1.1
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Play that, and you'll soon have a challenge on your hands! Each time the
 ball bounces, whether against a paddle or the wall, it speeds up by 10%.
 If you're quick, you can win simply because the computer tries to move
 toward where the ball currently is, rather than where it will be.
\end_layout

\begin_layout Standard
The game, while at least a bit exciting now, has a tendency to go on forever.
 This is because we haven't put any win conditions in.
 Here are some simple ones to add to the bottom of the loop in pong.rb:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		paddle.update(delay)
\end_layout

\begin_layout Plain Layout

		paddle2.update(delay)
\end_layout

\begin_layout Plain Layout

		ball.update(delay)
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if scores[0].score > 15
\end_layout

\begin_layout Plain Layout

			raise "Game over - you win!"
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if scores[1].score > 15
\end_layout

\begin_layout Plain Layout

			raise "Game over - you lose!"
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Raising an exception is hardly the most elegant way to congratulate a winner,
 but for now it gets our job done.
\end_layout

\begin_layout Subsection
Wrapup
\end_layout

\begin_layout Standard
Here's what you've accomplished over the previous demo:
\end_layout

\begin_layout Itemize
You use Sprites to put things on the screen now, rather than drawing it
 yourself,
\end_layout

\begin_layout Itemize
The sprites know how to react to user input
\end_layout

\begin_layout Itemize
They can move on their own
\end_layout

\begin_layout Itemize
You can check for collisions
\end_layout

\begin_layout Itemize
You can draw text as a sprite, and
\end_layout

\begin_layout Itemize
You can win or lose.
 
\end_layout

\begin_layout Standard
Congratulations, you've made your first Rubygame game!
\end_layout

\begin_layout Standard
While most of the code is far more elegant than the initial run, there's
 still a lot that can be done.
 The ball is fairly highly coupled with the paddles, for instance, and all
 our game objects live in the game loop.
 Also, every object that's in the game is created at the beginning - nothing's
 ever added or removed.
 What if you want to create new sprites on the fly, or get rid of them?
 That's what we'll be covering next when we re-make another game.
\end_layout

\begin_layout Section
Asteroids
\end_layout

\begin_layout Standard
The original Asteroids was released in 1979.
 We're moving up the technology tree now!
\end_layout

\begin_layout Subsection
A Game Engine
\end_layout

\begin_layout Standard
Before, every time we wanted to add another sprite to our game, we had to
 go through a number of hoops.
 We had to put it in another variable, draw it, update it, and, if necessary,
 pass keystrokes to it.
 Even more annoyingly, these steps were exactly the same for each new sprite.
 Wouldn't it be handy if we had a more standard way of doing that?
\end_layout

\begin_layout Standard
Yes.
 Yes it would.
 So let's do that.
 We're going to make a small game engine that'll take over a lot of the
 duties that our main() function was handling before.
 It'll keep hold of the screen and draw and update anything we tell it to.
 The code to do this is a bit long, but it should look familiar from earlier
 examples:
\end_layout

\begin_layout Standard
engine.rb
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'rubygame'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

include Rubygame
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Engine
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	attr_accessor :flags
\end_layout

\begin_layout Plain Layout

	attr_accessor :screen_width
\end_layout

\begin_layout Plain Layout

	attr_accessor :screen_height
\end_layout

\begin_layout Plain Layout

	attr_accessor :running
\end_layout

\begin_layout Plain Layout

	attr_accessor :bgcolor
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def initialize()
\end_layout

\begin_layout Plain Layout

		Rubygame.init()
\end_layout

\begin_layout Plain Layout

		@flags = [HWSURFACE, DOUBLEBUF]
\end_layout

\begin_layout Plain Layout

		@screen_width = 640
\end_layout

\begin_layout Plain Layout

		@screen_height = 480
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@clock = Clock.new
\end_layout

\begin_layout Plain Layout

		@clock.enable_tick_events()
\end_layout

\begin_layout Plain Layout

		target_framerate=30
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@queue = EventQueue.new()
\end_layout

\begin_layout Plain Layout

		@queue.enable_new_style_events()
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@bgcolor = [ 0, 0, 0 ]
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	# Lazy initialization for screen
\end_layout

\begin_layout Plain Layout

	def screen
\end_layout

\begin_layout Plain Layout

		if not @screen
\end_layout

\begin_layout Plain Layout

			resolution = [@screen_width, @screen_height]
\end_layout

\begin_layout Plain Layout

			@screen = Screen.new( resolution, 0, @flags )
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		return @screen
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def target_framerate=(value)
\end_layout

\begin_layout Plain Layout

		@clock.target_framerate = value
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def run
\end_layout

\begin_layout Plain Layout

		@running = true
\end_layout

\begin_layout Plain Layout

		while running
\end_layout

\begin_layout Plain Layout

			delay = @clock.tick.seconds
\end_layout

\begin_layout Plain Layout

			screen.fill( @bgcolor )
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			# TODO: Drawing
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			screen.flip()
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			@queue.each do |event|
\end_layout

\begin_layout Plain Layout

				case(event)
\end_layout

\begin_layout Plain Layout

				when Events::QuitRequested
\end_layout

\begin_layout Plain Layout

					@running = false
\end_layout

\begin_layout Plain Layout

				end
\end_layout

\begin_layout Plain Layout

				# TODO: Other events
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			# TODO: Updating
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is pretty much the same thing as we've been doing, except I've replaced
 the parts of the engine that might actually help us with #TODO statements.
 We'll be filling them in later with actual code.
\end_layout

\begin_layout Subsubsection
Lazy Initialization
\end_layout

\begin_layout Standard
We set up everything in our initialize() pretty much the same way we did
 before.
 The only difference is that we've put the screen creation in an accessor
 function.
 Why did we do this, rather than in the initialize() function?
\end_layout

\begin_layout Standard
The simple answer is that we don't want to set up the screen until we're
 ready for it.
 The initialize function is going to be called early on, but we might want
 to do other things before we decide what resolution or flags we want.
 So this way we can create a new instance of the Engine, do whatever other
 things we need to, and then pass in resolutions all before we use the screen.
 For example, here's a pretty minimal bit of code that uses the engine:
\end_layout

\begin_layout Standard
simple.rb
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'engine'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def main
\end_layout

\begin_layout Plain Layout

	engine = Engine.new
\end_layout

\begin_layout Plain Layout

	engine.screen_width = 1024
\end_layout

\begin_layout Plain Layout

	engine.screen_height = 768
\end_layout

\begin_layout Plain Layout

	engine.run
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if __FILE__ == $0
\end_layout

\begin_layout Plain Layout

	main()
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here, we tell our engine to use a different resolution than its default.
 If we'd set up the screen to be created during Initialize, then we'd have
 had to pass in things like resolution or flags - after a while we'd end
 up passing in quite a bit!
\end_layout

\begin_layout Standard
Note that we're not actually using the 'screen' variable at all.
 That's another way that lazy initialization helps out - it allows you to
 set up pretty complicated defaults.
 If you don't explicitly do anything with the screen earlier, the first
 time it's used is at the beginning of the 'run' function, which creates
 it then.
\end_layout

\begin_layout Subsubsection
Sprite Groups
\end_layout

\begin_layout Standard
We've got a number of TODO statements up there.
 Whereas before we had a variable for every object we were keeping track
 of, this time we'll just keep an array in the engine.
 That way we can update and draw everything that needs to be updated and
 drawn all in one spot, and if we wanted to add another sprite the only
 thing we have to do is add to the array.
\end_layout

\begin_layout Standard
First, let's add an array accessor and set it up in the initialize function:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	attr_accessor :components
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def initialize()
\end_layout

\begin_layout Plain Layout

		Rubygame.init()
\end_layout

\begin_layout Plain Layout

		@flags = [HWSURFACE, DOUBLEBUF]
\end_layout

\begin_layout Plain Layout

		@screen_width = 640
\end_layout

\begin_layout Plain Layout

		@screen_height = 480
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@clock = Clock.new
\end_layout

\begin_layout Plain Layout

		@clock.enable_tick_events()
\end_layout

\begin_layout Plain Layout

		target_framerate=30
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@queue = EventQueue.new()
\end_layout

\begin_layout Plain Layout

		@queue.enable_new_style_events()
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@bgcolor = [ 0, 0, 0 ]
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@components = Sprites::Group.new()
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That's no array!
\end_layout

\begin_layout Standard
Nope - because the idea of putting sprites into an array and then drawing
 and/or updating them is so common, Rubygame provides specialized arrays
 called Sprite Groups.
 They're subclasses of Array, so they can do everything that an ordinary
 array could, but they also include specialized functions just for sprites.
\end_layout

\begin_layout Standard
With that in mind, let's replace some of those TODOs.
 First, replace the line that says 
\begin_inset Quotes eld
\end_inset

# TODO: Drawing
\begin_inset Quotes erd
\end_inset

 with:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@components.draw(screen)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 'draw' function is one of the things that the Group class gives us.
 It goes through every sprite in the group and draws it to the surface you
 supply; in this case the screen.
\end_layout

\begin_layout Standard
Updating works similarly, replace the 
\begin_inset Quotes eld
\end_inset

TODO: Updating
\begin_inset Quotes erd
\end_inset

 with:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@components.update(delay)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this case, Group's 
\begin_inset Quotes eld
\end_inset

update
\begin_inset Quotes erd
\end_inset

 function takes any number of arguments.
 It then calls the 'update' function of every sprite in the collection and
 passes whatever arguments you gave.
 Importantly, the Sprite mixin creates a 'draw' function for you, but it
 doesn't add in an 'update'.
 If you're going to use the above functionality, you're going to have to
 add in an update function of your own.
 We'll come back to that soon.
\end_layout

\begin_layout Standard
So Group provides us with a built-in way to call 'draw' and 'update' on
 everything, but what if you wanted to call some other function on everything?
 It's still an array so you could iterate through it like any other, but
 Group provides us a simpler way.
 In the previous chapter, we had a 'key' function and dictionary that kept
 track of the state of the keyboard.
 Let's re-write our event loop to use something like that:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

			@queue.each do |event|
\end_layout

\begin_layout Plain Layout

				case(event)
\end_layout

\begin_layout Plain Layout

				when Events::QuitRequested
\end_layout

\begin_layout Plain Layout

					@running = false
\end_layout

\begin_layout Plain Layout

				when Events::QuitRequested
\end_layout

\begin_layout Plain Layout

					finished = true
\end_layout

\begin_layout Plain Layout

				when Events::KeyPressed
\end_layout

\begin_layout Plain Layout

					@components.call(:key, event.key, true)
\end_layout

\begin_layout Plain Layout

				when Events::KeyReleased
\end_layout

\begin_layout Plain Layout

					@components.call(:key, event.key, false)
\end_layout

\begin_layout Plain Layout

				end
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Group::call does the same thing that 'draw' and 'update' does, but on a
 more general level.
 It calls whatever function you specify (in this case 'key') and passes
 in whatever arguments you give it; it does this for every sprite in the
 group.
 Like 'update', it doesn't check to see if that function actually exists,
 so if you use 'call' be sure to define the function you're calling.
\end_layout

\begin_layout Subsection
Components
\end_layout

\begin_layout Standard
In our previous Pong example, there was some duplicated code.
 Both the Ball and Paddle class took a filename and created a surface from
 it, converted it and set its colorkey.
 As mentioned in the previous section, we also need to define an 'update'
 and 'key' function in every sprite we use.
\end_layout

\begin_layout Standard
We're going to create a base class for every sprite we put on the screen,
 so that all these functions will be defined.
 Let's put it at the top of engine.rb:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Component
\end_layout

\begin_layout Plain Layout

	include Sprites::Sprite
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def initialize(filename)
\end_layout

\begin_layout Plain Layout

		@filename = filename
\end_layout

\begin_layout Plain Layout

		@image = Surface.load(filename).convert()
\end_layout

\begin_layout Plain Layout

		@image.colorkey = [255,0,255]
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@rect = Rect.new(0,0,@image.w, @image.h)
\end_layout

\begin_layout Plain Layout

		@keys = {}
\end_layout

\begin_layout Plain Layout

		super()
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def key(sym, pressed)
\end_layout

\begin_layout Plain Layout

		@keys[sym] = pressed
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Sprite mixin gives us the 'draw' function, just like before.
 We've created an 'update' function that doesn't do anything - this is so
 our call to Group::update won't error out.
 All the other code should look familiar - it's the same kind of thing we
 did in the previous chapter, only now we've put it all in one place.
 Everything we put on the screen will be a subclass of Component.
\end_layout

\begin_layout Subsubsection
The Ship
\end_layout

\begin_layout Standard
Let's create our first component, then: The Player's ship
\end_layout

\begin_layout Standard
ship.rb
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'engine'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Ship < Component
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def initialize(engine)
\end_layout

\begin_layout Plain Layout

		super("ship.png")
\end_layout

\begin_layout Plain Layout

		@engine = engine
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		if @keys[:up]
\end_layout

\begin_layout Plain Layout

			@rect.top -= delay * 100
\end_layout

\begin_layout Plain Layout

		elsif @keys[:down]
\end_layout

\begin_layout Plain Layout

			@rect.top += delay * 100
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if @keys[:left]
\end_layout

\begin_layout Plain Layout

			@rect.left -= delay * 100
\end_layout

\begin_layout Plain Layout

		elsif @keys[:right]
\end_layout

\begin_layout Plain Layout

			@rect.right += delay * 100
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here we override the default empty 
\begin_inset Quotes eld
\end_inset

update
\begin_inset Quotes erd
\end_inset

 function to give the ship the ability to move around in response to keypresses.
 Because there's ever only going to be one ship and it's always going to
 look the same, the Ship's initialize function calls its superclass with
 'ship.png'.
 If we had something that behaved like the ship but looked differently,
 we'd probably keep the 'filename' argument, but in this case we don't need
 it.
\end_layout

\begin_layout Subsubsection
A Basic Skeleton
\end_layout

\begin_layout Standard
We've got a lot of framework out of the way, but we haven't actually done
 anything with it.
 Let's create a program that actually uses our framework!
\end_layout

\begin_layout Standard
asteroids.rb
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'engine'
\end_layout

\begin_layout Plain Layout

require 'ship'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def main
\end_layout

\begin_layout Plain Layout

	engine = Engine.new
\end_layout

\begin_layout Plain Layout

	engine.screen_width = 1024
\end_layout

\begin_layout Plain Layout

	engine.screen_height = 768
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	engine.screen
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	ship = Ship.new(engine)
\end_layout

\begin_layout Plain Layout

	engine.components << ship
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	engine.run
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if __FILE__ == $0
\end_layout

\begin_layout Plain Layout

	main()
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you run this, you'll see it's about as impressive as the end of chapter
 1, when you could move something around.
 We've gone through a lot of work and don't have a lot to show off.
 In fact, if you've ever played asteroids before you've noticed something
 about the way we move the ship around: It's entirely wrong!
\end_layout

\begin_layout Standard
In Asteroids, turning left or right rotates that ship in that direction
 and pressing forward accelerates.
 You can only fire directly ahead, so the inability to turn would be a large
 hindrance.
 Not to mention that the original game had the ship keep moving even after
 the player stopped pressing the button.
 How can we model that?
\end_layout

\begin_layout Subsubsection
Let's Get Physical
\end_layout

\begin_layout Standard
Science! Specifically, physics.
 Even more specifically, Newton's First Law: An object in motion tends to
 remain in motion.
 In order to model this, we need to keep a variable of how fast (and in
 what direction) we're traveling.
 This is actually similar to the Ball class in the previous chapter.
 In the same way we remembered what to add to its 'x' and 'y', we'll be
 keeping a 'velocity' array to do the same thing.
\end_layout

\begin_layout Standard
But where to keep this functionality? We could add this on to our Component,
 but remember that Component is our superclass for everything that shows
 up on screen.
 This includes things like the score, which doesn't even move at all.
 It'd be wasted functionality for anything that didn't preserve momentum
 - or anything that moves but does so in a different way.
\end_layout

\begin_layout Standard
Instead, let's make a subclass of Component that handles momentum.
 Put this between Component and the Engine itself:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class InertialComponent < Component
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	attr_accessor :top_speed
\end_layout

\begin_layout Plain Layout

	attr_reader :velocity
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def initialize(filename)
\end_layout

\begin_layout Plain Layout

		super
\end_layout

\begin_layout Plain Layout

		@top_speed = 100
\end_layout

\begin_layout Plain Layout

		@velocity = [ 0.0, 0.0 ]
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def accelerate(dx,dy)
\end_layout

\begin_layout Plain Layout

		@velocity[0] += dx
\end_layout

\begin_layout Plain Layout

		@velocity[1] += dy
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		# This is the part where we enforce the top speed
\end_layout

\begin_layout Plain Layout

		speed_squared = @velocity[0] * @velocity[0] +
\end_layout

\begin_layout Plain Layout

			@velocity[1] * @velocity[1]
\end_layout

\begin_layout Plain Layout

		if speed_squared > @top_speed * @top_speed
\end_layout

\begin_layout Plain Layout

			clamp_velocity(speed_squared)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	# If we're going faster than our top speed, change the speed to
\end_layout

\begin_layout Plain Layout

	# be the top speed
\end_layout

\begin_layout Plain Layout

	def clamp_velocity(speed_squared)
\end_layout

\begin_layout Plain Layout

		speed = Math.sqrt(speed_squared)
\end_layout

\begin_layout Plain Layout

		# Convert our velocity to a unit vector
\end_layout

\begin_layout Plain Layout

		unit_x = @velocity[0] / speed
\end_layout

\begin_layout Plain Layout

		unit_y = @velocity[1] / speed
\end_layout

\begin_layout Plain Layout

		# Now scale it back up to the top speed
\end_layout

\begin_layout Plain Layout

		@velocity = [unit_x * @top_speed, unit_y * @top_speed]
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		@rect.x += @velocity[0] * delay
\end_layout

\begin_layout Plain Layout

		@rect.y += @velocity[1] * delay
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Some of this looks familiar - the velocity stuff is similar to the Ball,
 but we've got a number of other things in there as well.
 We've put in a top speed and an 
\begin_inset Quotes eld
\end_inset

accelerate
\begin_inset Quotes erd
\end_inset

 function, and 
\begin_inset Quotes eld
\end_inset

clamp_velocity
\begin_inset Quotes erd
\end_inset

 makes sure it doesn't go over that max speed.
 The math involved is quite a bit of vector math, and as it happens Rubygame
 has a built-in class to handle vector math.
 If you're curious, Rubygame::Ftor is this class - but note that it's going
 away in Rubygame 3.0.
 That's why we're going with the basic operations here.
\end_layout

\begin_layout Standard
Let's re-write the Ship class to take advantage of this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Ship < InertialComponent
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def initialize(engine)
\end_layout

\begin_layout Plain Layout

		super("ship.png")
\end_layout

\begin_layout Plain Layout

		@top_speed = 400
\end_layout

\begin_layout Plain Layout

		@engine = engine
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		if @keys[:up]
\end_layout

\begin_layout Plain Layout

			accelerate(0,-1)
\end_layout

\begin_layout Plain Layout

		elsif @keys[:down]
\end_layout

\begin_layout Plain Layout

			accelerate(0, 1)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		super
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you run the program now, tap the 'up' key.
 The ship will slowly start wandering off the screen.
 Hold down the 'down' arrow and it'll back up and start moving in the other
 direction.
 It'll keep going, even after you let go.
\end_layout

\begin_layout Standard
That takes care of the momentum problem, but there's still no way to actually
 rotate the ship! In order to do that, we'll have to keep track of the ship's
 angle, rotate the image whenever that angle changes, and make it so that
 when you accelerate, you accelerate in the direction you're pointing rather
 than just straight ahead.
\end_layout

\begin_layout Standard
This means we're re-writing our ship class, again:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Ship < InertialComponent
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def initialize(engine)
\end_layout

\begin_layout Plain Layout

		super("ship.png")
\end_layout

\begin_layout Plain Layout

		@top_speed = 400
\end_layout

\begin_layout Plain Layout

		@original_image = @image
\end_layout

\begin_layout Plain Layout

		self.angle = 0
\end_layout

\begin_layout Plain Layout

		@engine = engine
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def angle=(value)
\end_layout

\begin_layout Plain Layout

		@angle = value
\end_layout

\begin_layout Plain Layout

		@image = @original_image.rotozoom(@angle, 1.0).convert
\end_layout

\begin_layout Plain Layout

		@image.colorkey = [255, 0, 255]
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		# Because the image might end up a different size than before,
\end_layout

\begin_layout Plain Layout

		# we need to change our @rect accordingly
\end_layout

\begin_layout Plain Layout

		old_center = @rect.center
\end_layout

\begin_layout Plain Layout

		@rect.w = @image.w
\end_layout

\begin_layout Plain Layout

		@rect.h = @image.h
\end_layout

\begin_layout Plain Layout

		@rect.center = old_center
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		radians = @angle * Math::PI / 180
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		if @keys[:up]
\end_layout

\begin_layout Plain Layout

			accelerate(Math.cos(radians) * 5,-Math.sin(radians) * 5)
\end_layout

\begin_layout Plain Layout

		elsif @keys[:down]
\end_layout

\begin_layout Plain Layout

			accelerate(-Math.cos(radians) * 5,Math.sin(radians) * 5)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if @keys[:left]
\end_layout

\begin_layout Plain Layout

			self.angle = @angle + 90 * delay
\end_layout

\begin_layout Plain Layout

		elsif @keys[:right]
\end_layout

\begin_layout Plain Layout

			self.angle = @angle - 90 * delay
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		super
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Rotozoom
\end_layout

\begin_layout Standard
Surface's 
\begin_inset Quotes eld
\end_inset

rotozoom
\begin_inset Quotes erd
\end_inset

 functionality does exactly what it sounds like: It gives you an image that's
 rotated and/or zoomed by the amounts you give it.
 Because this isn't necessarily a lossless operation, we rotate the original
 image rather than continually rotating ones that have already been rotated.
 We aren't interested in scaling our sprite at all, so we just pass in '1'
 as our zoom factor.
 The rotozoom function might return a surface that's a different size than
 the original surface (because otherwise the rotated image wouldn't fit),
 so we need to change our @rect information.
 Because the new image is a different size but the ship itself is still
 in the middle of the image, we need to re-center it to prevent it from
 appearing off-center as it was rotated.
\end_layout

\begin_layout Subsubsection
Trigonometry
\end_layout

\begin_layout Standard
This is the kind of vector math that we're doing ourselves in this book.
 When the ship was just facing up, it was easy to know what to add to its
 
\begin_inset Quotes eld
\end_inset

y
\begin_inset Quotes erd
\end_inset

 position and 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 position when the player accelerates.
 When the ship's at a 14 degree angle, on the other hand, it's a bit more
 difficult.
 Essentially, we accelerate the ship by the portion of its angle that applies
 to X, and the portion that applies to Y.
 As shown above, you can get those numbers by the cosine of the angle and
 the sine of the angle.
 We negate the 'y' portion because the screen's 
\begin_inset Quotes eld
\end_inset

y
\begin_inset Quotes erd
\end_inset

 increases as you go from top to bottom, which is the opposite of ordinary
 math.
\end_layout

\begin_layout Standard
If you run the game at this point, you now have a ship that's functional!
 Of course, it's missing a little something from the title - the asteroids!
\end_layout

\begin_layout Subsection
Asteroids and Projectiles
\end_layout

\begin_layout Standard
Like the ball in the Pong chapter, the Asteroids will be acting on their
 own.
 They'll just be moving and not doing anything terribly interesting while
 doing so:
\end_layout

\begin_layout Standard
asteroid.rb
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'engine'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Asteroid < InertialComponent
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def initialize(angle = nil)
\end_layout

\begin_layout Plain Layout

		super("asteroid.png")
\end_layout

\begin_layout Plain Layout

		@speed = 100
\end_layout

\begin_layout Plain Layout

		@angle = angle
\end_layout

\begin_layout Plain Layout

		setup_direction
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def setup_direction
\end_layout

\begin_layout Plain Layout

		@angle ||= rand(360)
\end_layout

\begin_layout Plain Layout

		ange = @angle * Math::PI / 180
\end_layout

\begin_layout Plain Layout

		@velocity[0] = Math.cos(angle) * @speed
\end_layout

\begin_layout Plain Layout

		@velocity[1] = -Math.sin(angle) * @speed
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This should look pretty familiar - we're setting up everything the way it
 was done in the ship, only instead of allowing for multiple angles, we're
 just picking one at random and going in that direction.
 Note that we're only picking one at random if we didn't pass one in - we'll
 be creating asteroids with specific angles later on.
\end_layout

\begin_layout Subsubsection
No, 'Asteroids', plural!
\end_layout

\begin_layout Standard
Right, the game wasn't called 
\begin_inset Quotes eld
\end_inset

Asteroid
\begin_inset Quotes erd
\end_inset

, after all.
 We need a way to make more than one of these.
 Not to mention, when they do appear, they need to appear from off-screen.
 The game would be far more difficult if an asteroid could simply appear
 out of nowhere at any point!
\end_layout

\begin_layout Standard
We could put all the logic to do this in our main asteroids.rb file, but
 what do we do later, when we want to spawn another asteroid? We need to
 make whatever manages the asteroids its own object, so that we can put
 all this code in one place and call it repeatedly.
\end_layout

\begin_layout Standard
I've created a class just for this purpose:
\end_layout

\begin_layout Standard
asteroid.rb
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class AsteroidBelt
\end_layout

\begin_layout Plain Layout

	attr_reader :asteroids
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def initialize(engine)
\end_layout

\begin_layout Plain Layout

		@engine = engine
\end_layout

\begin_layout Plain Layout

		@asteroids = []
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def spawn
\end_layout

\begin_layout Plain Layout

		asteroid = Asteroid.new()
\end_layout

\begin_layout Plain Layout

		screen = @engine.screen
\end_layout

\begin_layout Plain Layout

		x = 0
\end_layout

\begin_layout Plain Layout

		y = 0
\end_layout

\begin_layout Plain Layout

		if(asteroid.velocity[0] < 0)
\end_layout

\begin_layout Plain Layout

			x = @engine.screen.width + asteroid.rect.w
\end_layout

\begin_layout Plain Layout

		else
\end_layout

\begin_layout Plain Layout

			x = - asteroid.rect.w
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if(asteroid.velocity[1] < 0)
\end_layout

\begin_layout Plain Layout

			y = @engine.screen.height + asteroid.rect.h
\end_layout

\begin_layout Plain Layout

		else
\end_layout

\begin_layout Plain Layout

			y = - asteroid.rect.h
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		asteroid.rect.x = x
\end_layout

\begin_layout Plain Layout

		asteroid.rect.y = y
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@engine.components << asteroid
\end_layout

\begin_layout Plain Layout

		@asteroids << asteroid
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let's put this all together and get some asteroids on the field, shall we?
 Change the main asteroids.rb to look like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'engine'
\end_layout

\begin_layout Plain Layout

require 'ship'
\end_layout

\begin_layout Plain Layout

require 'asteroid'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def main
\end_layout

\begin_layout Plain Layout

	engine = Engine.new
\end_layout

\begin_layout Plain Layout

	engine.screen_width = 1024
\end_layout

\begin_layout Plain Layout

	engine.screen_height = 768
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	engine.screen
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	ship = Ship.new(engine)
\end_layout

\begin_layout Plain Layout

	engine.components << ship
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	belt = AsteroidBelt.new(engine)
\end_layout

\begin_layout Plain Layout

	belt.spawn
\end_layout

\begin_layout Plain Layout

	belt.spawn
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	engine.run
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if __FILE__ == $0
\end_layout

\begin_layout Plain Layout

	main()
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you run this, you'll see your ship (as before) and two asteroids, milling
 about.
 There are some problems, though:
\end_layout

\begin_layout Itemize
Once the asteroids go off the screen, they're gone for good,
\end_layout

\begin_layout Itemize
Once your ship goes off the screen, it's hard to get it back on,
\end_layout

\begin_layout Itemize
Your ship is immune to asteroids, and
\end_layout

\begin_layout Itemize
You can't shoot them
\end_layout

\begin_layout Standard
We're going to tackle that last point first:
\end_layout

\begin_layout Subsubsection
Projectiles
\end_layout

\begin_layout Standard
These are a lot like the asteroids, actually, except for two things:
\end_layout

\begin_layout Itemize
Unlike asteroids, they won't live forever, and
\end_layout

\begin_layout Itemize
Instead of having a random angle, they inherit it from the ship
\end_layout

\begin_layout Standard
Here's what they look like in action:
\end_layout

\begin_layout Standard
ship.rb
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Projectile < InertialComponent
\end_layout

\begin_layout Plain Layout

	attr_reader :ship
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def initialize(engine, ship)
\end_layout

\begin_layout Plain Layout

		super("projectile.png")
\end_layout

\begin_layout Plain Layout

		@speed = 500
\end_layout

\begin_layout Plain Layout

		@angle = ship.angle
\end_layout

\begin_layout Plain Layout

		@life = 2
\end_layout

\begin_layout Plain Layout

		@engine = engine
\end_layout

\begin_layout Plain Layout

		setup_direction
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def setup_direction
\end_layout

\begin_layout Plain Layout

		angle = @angle * Math::PI / 180
\end_layout

\begin_layout Plain Layout

		@velocity[0] = Math.cos(angle) * @speed
\end_layout

\begin_layout Plain Layout

		@velocity[1] = -Math.sin(angle) * @speed
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		super(delay)
\end_layout

\begin_layout Plain Layout

		@life -= delay
\end_layout

\begin_layout Plain Layout

		if(@life < 0)
\end_layout

\begin_layout Plain Layout

			@engine.components.delete(self)
\end_layout

\begin_layout Plain Layout

			@ship.shots.delete(self)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see, the similarities are pretty striking.
 If I wasn't trying to keep the code-wall-of-text factor to a minimum, I'd
 refactor out the common functionality between Asteroid and Projectile into
 its own class, and have those two inherit from it.
 For now, though, this will work fine.
\end_layout

\begin_layout Standard
You can see from the code where the first of our two differences from asteroids
 are - the @life variable controls how many seconds the projectile remains
 on screen.
 As far as the second, that comes in with the 'initialize' function; note
 that the angle is no longer optional.
\end_layout

\begin_layout Standard
That only leaves the other half - getting the ship to actually create and
 fire these things! Change the Ship's initialize to look like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	attr_accessor :shots
\end_layout

\begin_layout Plain Layout

	attr_reader :angle
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def initialize(engine)
\end_layout

\begin_layout Plain Layout

		super("ship.png")
\end_layout

\begin_layout Plain Layout

		@top_speed = 400
\end_layout

\begin_layout Plain Layout

		@original_image = @image
\end_layout

\begin_layout Plain Layout

		self.angle = 0
\end_layout

\begin_layout Plain Layout

		@engine = engine
\end_layout

\begin_layout Plain Layout

		@cooldown = 0
\end_layout

\begin_layout Plain Layout

		@shots = []
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And add this to the bottom of the ship's 
\begin_inset Quotes eld
\end_inset

update
\begin_inset Quotes erd
\end_inset

 function:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		@cooldown -= delay if @cooldown > 0
\end_layout

\begin_layout Plain Layout

		if @keys[:space] && @cooldown <= 0
\end_layout

\begin_layout Plain Layout

			@cooldown = 1.0
\end_layout

\begin_layout Plain Layout

			shot = Projectile.new(@engine,self)
\end_layout

\begin_layout Plain Layout

			shot.rect.centerx = @rect.centerx
\end_layout

\begin_layout Plain Layout

			shot.rect.centery = @rect.centery
\end_layout

\begin_layout Plain Layout

			@engine.components << shot
\end_layout

\begin_layout Plain Layout

			@shots << shot
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first thing we do is establish a 'cooldown' variable that keeps track
 of how long it'll be until the next time we can shoot something.
 This is mainly to prevent the player from flooding the area with projectiles.
 If the cooldown is 0 and they're pressing the 'space' button, we re-set
 the cooldown and create a new projectile.
\end_layout

\begin_layout Standard
If you try this out, it's not immediately obvious that the projectiles are
 dying after two seconds.
 At 500 pixels per second and living for two seconds, they'll have covered
 1000 pixels, which is almost the entire width of the screen.
 To see the countdown in action, aim the ship at the lower-right of the
 screen and shoot.
 You should be able to see them expire.
\end_layout

\begin_layout Subsection
Blowing stuff up
\end_layout

\begin_layout Standard
Of course, right now shooting at the asteroids does absolutely nothing and,
 much to their frustration, your ship remains cheerfully immune.
 Let's change all that.
\end_layout

\begin_layout Standard
In the Pong chapter, we discussed a few methods of managing collision detection.
 This time around, we're going to create a class whose entire purpose is
 watching for collisions and dealing with them:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class CollisionWatcher
\end_layout

\begin_layout Plain Layout

	def initialize(engine,ship,belt)
\end_layout

\begin_layout Plain Layout

		@engine = engine
\end_layout

\begin_layout Plain Layout

		@ship = ship
\end_layout

\begin_layout Plain Layout

		@belt = belt
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		shots = @ship.shots.dup
\end_layout

\begin_layout Plain Layout

		@belt.asteroids.dup.each do |rock|
\end_layout

\begin_layout Plain Layout

			if rock.rect.collide_rect?(@ship.rect)
\end_layout

\begin_layout Plain Layout

				game_over
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

			shots.each do |shot|
\end_layout

\begin_layout Plain Layout

				if shot.rect.collide_rect?(rock.rect)
\end_layout

\begin_layout Plain Layout

					kill_both(rock,shot)
\end_layout

\begin_layout Plain Layout

				end
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def game_over
\end_layout

\begin_layout Plain Layout

		raise "Game Over!"
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def kill_both(rock, shot)
\end_layout

\begin_layout Plain Layout

		@engine.components.delete(rock)
\end_layout

\begin_layout Plain Layout

		@engine.components.delete(shot)
\end_layout

\begin_layout Plain Layout

		@ship.shots.delete(shot)
\end_layout

\begin_layout Plain Layout

		@belt.asteroids.delete(rock)
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Oh, raise 
\begin_inset Quotes eld
\end_inset

Game Over!
\begin_inset Quotes erd
\end_inset

, you're such great placeholder code.
\end_layout

\begin_layout Subsubsection
Duplication
\end_layout

\begin_layout Standard
Rather than go through the shots and asteroids arrays as they are, you may
 have noticed that we duplicate the arrays and go through that duplicate.
 The reason we're doing this is that it's likely our code will modify the
 original arrays.
 The kill_both function, specifically, changes both of our arrays.
 It's important to always iterate over arrays that aren't going to change
 because if they do it's possible you'll end up iterating over some parts
 more than once or not at all.
 And that's the best case scenario!
\end_layout

\begin_layout Subsubsection
Continually Updated
\end_layout

\begin_layout Standard
The CollisionWatcher would work great if not for one small problem: That
 update(delay) function needs to be called every frame, and right now there's
 not a good way to do that.
 You could go back to the Engine class and hack it in, but that'd be creating
 a rather special case just for this once class - we'd like to keep the
 Engine generic (later we'll have another class use this continual updating,
 so we want something reusable).
\end_layout

\begin_layout Standard
If it weren't for the fact that it was built almost entirely just to draw
 things, the Component class would be ideal - the engine already knows how
 to add and remove them, and to update them each frame.
 But, as mentioned, that class is made explicitly to draw.
\end_layout

\begin_layout Standard
So let's make one that isn't:
\end_layout

\begin_layout Standard
engine.rb
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class BareComponent
\end_layout

\begin_layout Plain Layout

	include Sprites::Sprite
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def initialize
\end_layout

\begin_layout Plain Layout

		super
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def key(sym,pressed)
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def draw(screen)
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that this class, despite its name, is entirely unrelated to the Component
 class - it doesn't inherit at all.
 Despite that fact, this will work - the main game loop only ever calls
 'key', 'draw', and 'update'.
 This is an example of 
\begin_inset Quotes eld
\end_inset

duck typing
\begin_inset Quotes erd
\end_inset

 - the BareComponent looks like a Component, it quacks like a Component,
 so as far as the Engine can tell, it's not any different.
 Duck typing is a very powerful tool, but also somewhat dangerous.
 If we add something to the regular Component class that the game loop depends
 on and forget to add it to classes that are pretending to be Components,
 we'll get an error.
\end_layout

\begin_layout Standard
This class is an ideal base class for our CollisionWatcher - it'll allow
 the watcher to be updated every frame, but we don't have to worry about
 drawing it because the BareComponent simply stubs that out.
 Let's change our CollisionWatcher accordingly:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class CollisionWatcher < BareComponent
\end_layout

\begin_layout Plain Layout

	def initialize(engine,ship,belt)
\end_layout

\begin_layout Plain Layout

		@engine = engine
\end_layout

\begin_layout Plain Layout

		@ship = ship
\end_layout

\begin_layout Plain Layout

		@belt = belt
\end_layout

\begin_layout Plain Layout

		super()
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That's literally the only change we need to make to the watcher.
 Now let's add it to our main asteroids.rb file:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def main
\end_layout

\begin_layout Plain Layout

	engine = Engine.new
\end_layout

\begin_layout Plain Layout

	engine.screen_width = 1024
\end_layout

\begin_layout Plain Layout

	engine.screen_height = 768
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	engine.screen
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	ship = Ship.new(engine)
\end_layout

\begin_layout Plain Layout

	engine.components << ship
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	belt = AsteroidBelt.new(engine)
\end_layout

\begin_layout Plain Layout

	belt.spawn
\end_layout

\begin_layout Plain Layout

	belt.spawn
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	watcher = CollisionWatcher.new(engine,ship,belt)
\end_layout

\begin_layout Plain Layout

	engine.components << watcher
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	engine.run
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now if you run the game, you'll be able to shoot and kill asteroids, as
 well as be killed by asteroids.
 In fact, that second part may lead to:
\end_layout

\begin_layout Subsubsection
I'm dying before I can even play!
\end_layout

\begin_layout Standard
If you start the game and die immediately, it's because one of the four
 spawn points for the asteroids is in the upper-left part of the screen,
 right next to where the ship starts out.
 So you last only a few frames at best before the asteroid hits the ship.
 This is an easy fix, just change the ship setup in asteroids.rb to:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	ship = Ship.new(engine)
\end_layout

\begin_layout Plain Layout

	ship.rect.centerx = engine.screen_width / 2
\end_layout

\begin_layout Plain Layout

	ship.rect.centery = engine.screen_height / 2
\end_layout

\begin_layout Plain Layout

	engine.components << ship
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now you start right in the middle.
\end_layout

\begin_layout Subsection
Making it Last
\end_layout

\begin_layout Standard
We made a list of problems earlier, and then we took care of a few.
 There are some left, however:
\end_layout

\begin_layout Itemize
Once the asteroids go off the screen, they're gone for good, and
\end_layout

\begin_layout Itemize
Once your ship goes off the screen, it's hard to get it back on.
\end_layout

\begin_layout Standard
In the original Asteroids, once something went off the screen, it wrapped
 around to the other side.
 Wouldn't it be nice if our game had that feature? Well, the upshot to being
 the person making the game is that it can have any feature you want it
 to have:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class WraparoundWatcher < BareComponent
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def initialize(engine)
\end_layout

\begin_layout Plain Layout

		@engine = engine
\end_layout

\begin_layout Plain Layout

		super()
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		@engine.components.each do |item|
\end_layout

\begin_layout Plain Layout

			if item.rect
\end_layout

\begin_layout Plain Layout

				if item.rect.right < 0
\end_layout

\begin_layout Plain Layout

					item.rect.left = @engine.screen.w
\end_layout

\begin_layout Plain Layout

				elsif item.rect.left > @engine.screen.w
\end_layout

\begin_layout Plain Layout

					item.rect.right = 0
\end_layout

\begin_layout Plain Layout

				end
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				if item.rect.bottom < 0
\end_layout

\begin_layout Plain Layout

					item.rect.top = @engine.screen.h
\end_layout

\begin_layout Plain Layout

				elsif item.rect.top > @engine.screen.h
\end_layout

\begin_layout Plain Layout

					item.rect.bottom = 0
\end_layout

\begin_layout Plain Layout

				end
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Similar to the CollisionWatcher but even more simple - rather than take
 in a list of the various things we want to watch, we just take in the engine.
 Everything that gets drawn should be wrapped around, after all.
\end_layout

\begin_layout Subsubsection
More Ducks
\end_layout

\begin_layout Standard
Note that, before we check the component's rect to see if we should move
 it to the other side of the screen, we check to see if it has a rect.
 You might wonder why that is - after all, everything has a rect, right?
 Well, everything that gets 
\emph on
drawn 
\emph default
has a rect.
\end_layout

\begin_layout Standard
Remember that we have two components that don't have rects, and you just
 wrote one of them! (The CollisionWatcher is the other one).
 This is an instance of the need to be careful when Duck Typing.
 
\end_layout

\begin_layout Subsubsection
Integration
\end_layout

\begin_layout Standard
Let's put this new watcher in our main function:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def main
\end_layout

\begin_layout Plain Layout

	engine = Engine.new
\end_layout

\begin_layout Plain Layout

	engine.screen_width = 1024
\end_layout

\begin_layout Plain Layout

	engine.screen_height = 768
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	engine.screen
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	ship = Ship.new(engine)
\end_layout

\begin_layout Plain Layout

	ship.rect.centerx = engine.screen_width / 2
\end_layout

\begin_layout Plain Layout

	ship.rect.centery = engine.screen_height / 2
\end_layout

\begin_layout Plain Layout

	engine.components << ship
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	belt = AsteroidBelt.new(engine)
\end_layout

\begin_layout Plain Layout

	belt.spawn
\end_layout

\begin_layout Plain Layout

	belt.spawn
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	watcher = CollisionWatcher.new(engine,ship,belt)
\end_layout

\begin_layout Plain Layout

	engine.components << watcher
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	wrap = WraparoundWatcher.new(engine)
\end_layout

\begin_layout Plain Layout

	engine.components << wrap
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	engine.run
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is getting larger, but it's taking much longer to do so than our Pong
 example did.
 That's one of the benefits of having an engine in place, a great deal of
 code can be factored out into it.
\end_layout

\begin_layout Standard
If you play this now, you'll be able to fly off the screen and back around
 the other side.
 So will your projectiles (it'll be pretty easy to see them vanish after
 two seconds now) and asteroids.
\end_layout

\begin_layout Subsection
I won, I think.
\end_layout

\begin_layout Standard
After you've shot the two asteroids, there's not a whole lot else to do.
 You just float around in space and not much else.
 We could end the game here, do a raise 
\begin_inset Quotes eld
\end_inset

you won
\begin_inset Quotes erd
\end_inset

 and call it a day, or we could keep throwing asteroids at the player!
\end_layout

\begin_layout Standard
We've already got the AsteroidBelt class that handles spawning new asteroids
 in - let's have it do this automatically.
 Add an update(delay) function to the AsteroidBelt class that looks like
 this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		while @asteroids.size < 5
\end_layout

\begin_layout Plain Layout

			spawn
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That'll make sure there are at least 5 asteroids on the screen at all times.
 Or it would, if that 'update' function were being called at all.
 But wait, we just wrote something to do exactly that! Change the beginning
 of AsteroidBelt to the following:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class AsteroidBelt < BareComponent
\end_layout

\begin_layout Plain Layout

	attr_accessor :asteroids
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def initialize(engine)
\end_layout

\begin_layout Plain Layout

		@engine = engine
\end_layout

\begin_layout Plain Layout

		@asteroids = []
\end_layout

\begin_layout Plain Layout

		super()
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Of course, this still doesn't work because we haven't added the asteroid
 belt to our engine.
 Go back to the main() function in asteroids.rb and change belt's setup to:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	belt = AsteroidBelt.new(engine)
\end_layout

\begin_layout Plain Layout

	engine.components << belt
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can remove the the two calls to spawn() that were there; now that the
 belt's update is being called every frame, you don't need it.
\end_layout

\begin_layout Subsubsection
A Proper Game Over
\end_layout

\begin_layout Standard
Okay, so now you can't win.
 But you can lose in style, right? Let's get rid of that raise 
\begin_inset Quotes eld
\end_inset

Game Over
\begin_inset Quotes erd
\end_inset

 and replace it with something visual.
 Go to the CollisionWatcher and change its game_over() function to look
 like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def game_over
\end_layout

\begin_layout Plain Layout

		over = Component.new("gameover.png")
\end_layout

\begin_layout Plain Layout

		@engine.components << over
\end_layout

\begin_layout Plain Layout

		over.rect.centerx = @engine.screen.w / 2
\end_layout

\begin_layout Plain Layout

		over.rect.centery = @engine.screen.h / 2
\end_layout

\begin_layout Plain Layout

		@engine.components.delete(@ship)
\end_layout

\begin_layout Plain Layout

		@ship.rect = nil
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There's just one problem with this code.
 Earlier, in the update() function, we check to see if the ship's colliding...
 and we keep doing this even if it's dead! Not to mention we seemed to have
 recklessly changed the ship's rectangle to nil, even though that's almost
 certainly going to cause it to crash.
\end_layout

\begin_layout Standard
I'm doing that in order to prevent us from adding more code to the Ship
 class.
 The normal way to do something like this would be to have an 'alive' accessor
 inside Ship that reflects whether it's alive or not.
 Since I'm trying to keep the walls of code to a minimum, I'm going to use
 the ship's rectangle as this indicator.
 We just need to change CollisionWatcher's update() to not crash on it:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		shots = @ship.shots.dup
\end_layout

\begin_layout Plain Layout

		if(@ship.rect)
\end_layout

\begin_layout Plain Layout

			@belt.asteroids.dup.each do |rock|
\end_layout

\begin_layout Plain Layout

				if rock.rect.collide_rect?(@ship.rect)
\end_layout

\begin_layout Plain Layout

					game_over
\end_layout

\begin_layout Plain Layout

					return unless @ship.rect
\end_layout

\begin_layout Plain Layout

				end
\end_layout

\begin_layout Plain Layout

				shots.each do |shot|
\end_layout

\begin_layout Plain Layout

					if shot.rect.collide_rect?(rock.rect)
\end_layout

\begin_layout Plain Layout

						kill_both(rock,shot)
\end_layout

\begin_layout Plain Layout

					end
\end_layout

\begin_layout Plain Layout

				end
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that we're checking the rectangle twice - once before the loop so we
 can save some time, and once inside the rocks/ship collision loop.
 The latter is because the rect gets changed to null the instant it hits
 a rock, and it'll crash on the next iteration of the loop unless we exit
 before then.
\end_layout

\begin_layout Subsection
Wrapup
\end_layout

\begin_layout Standard
Another game complete! This time you:
\end_layout

\begin_layout Itemize
Put a lot of otherwise duplicated code into a game engine
\end_layout

\begin_layout Itemize
Created a hierarchy of sprites to do away with even more duplicate code
\end_layout

\begin_layout Itemize
Used the terrifying power of math and vectors
\end_layout

\begin_layout Itemize
Got away with Duck Typing.
\end_layout

\begin_layout Subsubsection
Excercises
\end_layout

\begin_layout Standard
If you'd like to play around some more with this game, here are some things
 you can do:
\end_layout

\begin_layout Description
Keep
\begin_inset space ~
\end_inset

Score Award points for destroying asteroids and display those points at
 the top of the screen.
 You can probably rip off Pong's scoreboard pretty easily.
\end_layout

\begin_layout Description
Shielding Some versions of Asteroids have a shield the player can activate,
 that makes them temporarily invincible.
 Use the @life and @cooldown features as examples of how to start with this.
\end_layout

\begin_layout Description
Fragments When you explode an asteroid, it should blow up into other, smaller
 asteroids! Either use a smaller asteroid image or shrink it yourself with
 rotozoom.
 Make sure you remove them entirely once they get small enough, or you're
 going to have a very interesting problem on your hands.
\end_layout

\begin_layout Description
Multiple
\begin_inset space ~
\end_inset

Lives Instead of losing the instant you touch an asteroid, have the player
 lose a life and put them back in the middle.
 Use what you did in 'shielding' to make sure they don't explode if there's
 already an asteroid there.
 Use what you did in 'keep score' to show how many lives the player has
 left.
\end_layout

\begin_layout Section
Shoot-em-up (Now with Sound!)
\end_layout

\begin_layout Standard
This project's going to be very similar to the last one - you'll even be
 using the engine you designed in the previous chapter.
 We'll be adding features to it to handle the audio portion of games, however.
\end_layout

\begin_layout Subsection
Setting Up
\end_layout

\begin_layout Standard
Whenever I'm starting up a new project, the first thing I like to do is
 to get a bare-minimum program written.
 Usually this does nothing but put the window on the screen, but it's somewhere
 to start from:
\end_layout

\begin_layout Standard
shoot-em.rb
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'engine'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def main
\end_layout

\begin_layout Plain Layout

	engine = Engine.new
\end_layout

\begin_layout Plain Layout

	engine.screen_width = 1024
\end_layout

\begin_layout Plain Layout

	engine.screen_height = 768
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	engine.run
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if __FILE__ == $0
\end_layout

\begin_layout Plain Layout

	main()
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you're like me, you've been organizing these files in separate directories
 for each chapter.
 If that's the case, remember to copy engine.rb over from chapter 3, as the
 code above depends on it.
\end_layout

\begin_layout Standard
Running this is pretty much exactly what you'd expect: A big blank screen.
 It's not exciting but it's beneficial to write the bare-bones portion first
 for a few reasons:
\end_layout

\begin_layout Subsubsection
Why?
\end_layout

\begin_layout Description
You
\begin_inset space ~
\end_inset

know
\begin_inset space ~
\end_inset

everything's
\begin_inset space ~
\end_inset

working: In an entirely new project there's often setup that needs to be
 done beforehand - if this is a new computer, you'll need to install Rubygame,
 for instance.
 Making a simple program ensures that everything was set up correctly.
 A complex program would also do this, but it'd take you a lot longer to
 write just to know if things worked.
\end_layout

\begin_layout Description
You
\begin_inset space ~
\end_inset

have
\begin_inset space ~
\end_inset

a
\begin_inset space ~
\end_inset

starting
\begin_inset space ~
\end_inset

point: In programming, as in writing, sometimes a large blank page can be
 intimidating.
 This way you've got a simple starting point.
 If you've written an engine like we have, you've got more than that - you
 have a point where you know you need to go next.
 In our case, it's adding items to the engine.
\end_layout

\begin_layout Description
You
\begin_inset space ~
\end_inset

can
\begin_inset space ~
\end_inset

develop
\begin_inset space ~
\end_inset

incrementally: As we've done in the previous projects, we'll be starting
 from a very simple base and expanding as we go.
 This kind of 
\begin_inset Quotes eld
\end_inset

bottom-up
\begin_inset Quotes erd
\end_inset

 design can be very useful for prototyping games.
\end_layout

\begin_layout Standard
Speaking of developing incrementally, let's reproduce the same first steps
 that we've done in the previous chapters: Taking an image and displaying
 it on the screen:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def main
\end_layout

\begin_layout Plain Layout

	engine = Engine.new
\end_layout

\begin_layout Plain Layout

	engine.screen_width = 1024
\end_layout

\begin_layout Plain Layout

	engine.screen_height = 768
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	engine.screen
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	player = Component.new("1945.bmp")
\end_layout

\begin_layout Plain Layout

	engine.components << player
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	engine.run
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Ye Gods, What Have We Done!?
\end_layout

\begin_layout Standard
If you run that, you'll quickly see that is not exactly an image of the
 player.
 It looks like it's an image of every sprite you'd see in the entire game.
 And it looks like that because that's exactly what it is! In fact, if you
 take a look at the sample code directory for chapter 4, you'll see that
 
\begin_inset Quotes eld
\end_inset

1945.bmp
\begin_inset Quotes erd
\end_inset

 is the only image in it.
\end_layout

\begin_layout Standard
What gives?
\end_layout

\begin_layout Subsection
Sprite Sheets
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

1945.bmp
\begin_inset Quotes erd
\end_inset

 is an example of what's called a 
\begin_inset Quotes eld
\end_inset

sprite sheet
\begin_inset Quotes erd
\end_inset

.
 Instead of having a dozen or more separate images on disk, you can have
 one image that has everything you need.
 
\end_layout

\begin_layout Subsubsection
Pro
\end_layout

\begin_layout Standard
It may not be immediately obvious why this is any better, but it can have
 a few advantages:
\end_layout

\begin_layout Description
Speed: Loading an image from disk involves a certain amount of overhead
 - the system needs to locate the file, verify it exists, ensure you have
 permissions to read it, etc.
 Doing this for one file is relatively quick, but if you're doing it hundreds
 of times...
 not as much.
 This setup difference is even more pronounced if you're not getting your
 images from disk but are instead getting them over a network connection.
 If all your sprites are in one file, you only have to do this once.
 
\end_layout

\begin_layout Description
Ease
\begin_inset space ~
\end_inset

of
\begin_inset space ~
\end_inset

Animation: If you look at the sheet you'll see there are a number of sprites
 that are identical except for a few subtle differences (the ship and submarine,
 for example).
 These are intended to be animated, by swapping one image out and replacing
 it with another one.
 Rather than have to load in a number of separate files and then keep track
 of which ones are which part of the animation, you can have one file and
 have the parts which need to be animated right next to each other.
\end_layout

\begin_layout Description
Texture
\begin_inset space ~
\end_inset

Use: It's no accident that the 1945.bmp file is 1024 pixels wide.
 You'd need to add on padding to make it that tall, but that's not terribly
 difficult.
 If you're creating a 3D game and looking for textures in the wild, you'll
 likely find many that are 1024x1024 or 512x512 - that's because many 3D
 libraries require textures with sizes that are a power of 2.
 Additionally, 3D cards have a limit on how many textures they can load
 at once.
 Like the 'files' example above, it's easier on them to have one big texture
 than a large amount of small ones.
 We're not using 3D in this example, but it's still a reason to go with
 spritesheets.
\end_layout

\begin_layout Subsubsection
Con
\end_layout

\begin_layout Standard
It's not all advantages, however.
 There are downsides to spritesheets:
\end_layout

\begin_layout Description
Complexity: Loading one image and displaying it is easy.
 Loading a giant image and picking out only the part you need isn't as simple.
 Furthermore, if each object has its own image, that object can be responsible
 for loading it from disk.
 If each object shares an image, the loading has to be handled somewhere
 else.
\end_layout

\begin_layout Description
Difficulty
\begin_inset space ~
\end_inset

of
\begin_inset space ~
\end_inset

Change: If you find that one of your sprites doesn't look the way you wanted
 it to, you can open up its file and change it.
 You can do the same thing in a spritesheet, but what if you wanted to change
 the size of one of the sprites? You'd have to move everything else on the
 spritesheet around.
\end_layout

\begin_layout Standard
These can be mitigated to some extent by taking a hybrid approach: Create
 the sprites in their own separate files and then use another program to
 join them together in a spritesheet.
 This way editing them is simple as long as you remember to run the joining
 program.
\end_layout

\begin_layout Subsubsection
Supporting Spritesheets
\end_layout

\begin_layout Standard
Our existing components only know how to load and display ordinary images.
 Let's add a class to our engine.rb that can handle sprite sheets:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class SpriteSheetComponent < Component
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def initialize(filename, srcrect)
\end_layout

\begin_layout Plain Layout

		@srcrect = srcrect
\end_layout

\begin_layout Plain Layout

		super(filename)
\end_layout

\begin_layout Plain Layout

		@rect = Rect.new(0,0, srcrect.w, srcrect.h)
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def draw(screen)
\end_layout

\begin_layout Plain Layout

		@image.blit(screen, @rect.topleft, @srcrect)
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The only difference here is that these components require a source rectangle
 - that's the area of the spritesheet we'll be using as the image.
 As you can see, Surface::blit takes an optional extra argument which is
 exactly that.
 This code will draw only the portion of the main image specified in @srcrect,
 and it'll draw that portion at @rect.topleft.
 Note that, even though the Component superclass sets @rect, we re-set it
 here.
 That's because the actual size of this component is what's in @srcrect.
\end_layout

\begin_layout Standard
Now to use it - change our shoot-em.rb file to this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'engine'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

include Rubygame
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def main
\end_layout

\begin_layout Plain Layout

	engine = Engine.new
\end_layout

\begin_layout Plain Layout

	engine.screen_width = 1024
\end_layout

\begin_layout Plain Layout

	engine.screen_height = 768
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	engine.screen
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	src = Rect.new(4,4,32,32)
\end_layout

\begin_layout Plain Layout

	player = SpriteSheetComponent.new("1945.bmp",src)
\end_layout

\begin_layout Plain Layout

	engine.components << player
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	engine.run
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if __FILE__ == $0
\end_layout

\begin_layout Plain Layout

	main()
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Run this, and you'll see an airplane in the upper-left corner, which is
 exactly what we want.
 Well, we won't want it to start the upper-left corner, and we probably
 want to do something about that blue background, but there's a more pressing
 issue:
\end_layout

\begin_layout Subsubsection
This is the least efficient thing you've ever done
\end_layout

\begin_layout Standard
You might have noticed this back in the asteroids example.
 The Component class takes in a filename and loads it from disk, then puts
 it in memory.
 It does this every time you create a new component.
 So for every asteroid on the screen, each one has a separate copy of the
 image in memory, even though these copies look exactly the same.
\end_layout

\begin_layout Standard
That's only somewhat wasteful when you've got 5 asteroids and the asteroids
 aren't that big.
 When you're planning on dozens of sprites and the image you're loading
 over and over again is nearly 800kb...
 then you have a problem.
\end_layout

\begin_layout Standard
A helpful feature in this instance would be to have a globally-accessable
 image loader.
 You could give it a filename and, if it hadn't already loaded that from
 disk it'd do so.
 If it already had the image, you'd get that.
 That way we'd get the benefits of the spritesheet by only ever having the
 one image in memory at any time.
\end_layout

\begin_layout Standard
We could write that...
 but we don't have to! Rubygame has already done this for us using a module
 called NamedResource.
 It does exactly what's specified above not only for images, but also for
 sounds and music.
\end_layout

\begin_layout Standard
Change our Component initializer to look like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def initialize(filename)
\end_layout

\begin_layout Plain Layout

		@filename = filename
\end_layout

\begin_layout Plain Layout

		Surface.autoload_dirs = ["."]
\end_layout

\begin_layout Plain Layout

		initial = Surface[filename]
\end_layout

\begin_layout Plain Layout

		if(!initial.colorkey)
\end_layout

\begin_layout Plain Layout

			initial.colorkey = [255,0,255]
\end_layout

\begin_layout Plain Layout

			Surface[filename] = initial.convert
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		@image = Surface[filename]
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@rect = Rect.new(0,0,@image.w, @image.h)
\end_layout

\begin_layout Plain Layout

		@keys = {}
\end_layout

\begin_layout Plain Layout

		super()
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Because this is the superclass of SpriteSheetComponent, it'll gain the benefits
 of the resource re-use as well.
\end_layout

\begin_layout Subsubsection
NamedResource
\end_layout

\begin_layout Standard
You can load an instance of any class that mixes in NamedResource exactly
 as we did above:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ClassThatUsesNamedResource[filename]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If it's already loaded that filename you'll get that instance, and if it
 hasn't already loaded it, it'll do so then.
 It looks for the filename in an array called 
\begin_inset Quotes eld
\end_inset

autoload_dirs
\begin_inset Quotes erd
\end_inset

, and this array isn't set up by default, so you'll need to put something
 in it.
 In our case, we set it to the current directory.
 If you had an 'images' directory, you'd probably add it there.
\end_layout

\begin_layout Standard
If it's so simple, you may be asking, why all the hubbub with checking the
 color key and doing conversions? Recall that, if you want your image blitting
 to be at all fast, you need to convert the image's format to the screen's
 format.
 NamedResource doesn't do that for us, so we need to do it ourselves.
 But the 'convert' function 
\emph on
always
\emph default
 returns a new image, even if the original image didn't need converting,
 so we can't do it every single time.
 
\end_layout

\begin_layout Standard
We solve this problem by checking the colorkey of the image.
 If the image was just loaded from disk, it won't have one, so we know the
 conversion needs to happen.
 We do the conversion, put the result back in the named resource so that
 future reads from it will get our converted image, and set the color key
 so next time we check the image we don't convert it.
\end_layout

\begin_layout Standard
Somewhat complicated, yes, but more because of the complexity of Surfaces
 rather than NamedResource itself.
 The benefit is that you gain the ability to load a surface from anywhere
 in your program, and you won't have multiple copies of that same surface
 wasting memory.
\end_layout

\begin_layout Subsubsection
That's not our color key
\end_layout

\begin_layout Standard
The default colorkey of components is the lovely magenta color we used in
 the previous chapters.
 That doesn't help us one bit with Spritelib, which is using a shade of
 blue for its color key on this image.
 Let's add on to Component so we can make the color key whatever we want
 it to be:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def colorkey=(key)
\end_layout

\begin_layout Plain Layout

		@image.colorkey = key
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now let's tell the engine to use it in shoot-em.rb:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	src = Rect.new(4,4,32,32)
\end_layout

\begin_layout Plain Layout

	player = SpriteSheetComponent.new("1945.bmp",src)
\end_layout

\begin_layout Plain Layout

	player.colorkey = [0, 67,171]
\end_layout

\begin_layout Plain Layout

	engine.components << player
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you run this you'll see it's not perfect - there are still blue dots
 around the edges.
 Because the game was designed to be played on a blue background (i.e.
 flying over the sea), many of the sprites have blue outlines so they can
 be seen apart from this background.
 This isn't the modern way to blend such an outline in, but the art style
 of Spritelib is purposefully retro.
\end_layout

\begin_layout Subsection
The Player
\end_layout

\begin_layout Standard
This section's going to be very similar to code you've already seen, because
 there aren't that many ways to move something around the screen:
\end_layout

\begin_layout Standard
plane.rb
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'engine'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class PlayerPlane < SpriteSheetComponent
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def initialize(filename, srcrect)
\end_layout

\begin_layout Plain Layout

		super
\end_layout

\begin_layout Plain Layout

		reset
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def reset
\end_layout

\begin_layout Plain Layout

		@speed = 350
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		change = delay * @speed
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if @keys[:left]
\end_layout

\begin_layout Plain Layout

			@rect.x -= change
\end_layout

\begin_layout Plain Layout

		elsif @keys[:right]
\end_layout

\begin_layout Plain Layout

			@rect.x += change
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if @keys[:up]
\end_layout

\begin_layout Plain Layout

			@rect.y -= change
\end_layout

\begin_layout Plain Layout

		elsif @keys[:down]
\end_layout

\begin_layout Plain Layout

			@rect.y += change
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That should look pretty familiar.
 Running the game now gives you a controllable sprite.
 We've once again repeated what we did back in Chapter 1! And like we did
 for Pong in chapter 2, we have a 'reset' call.
 This game will feature multiple lives, so the ability to re-set the player
 back to the original settings will come in handy.
\end_layout

\begin_layout Subsubsection
Putting the Player in Their Place
\end_layout

\begin_layout Standard
Like in Asteroids, it'd be incredibly annoying to have the player start
 in the upper left corner because enemies are going to be coming from (among
 other places) right there.
 So let's modify our reset code to move the player toward the bottom-center:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def reset
\end_layout

\begin_layout Plain Layout

		@speed = 350
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		screen = Screen.get_surface()
\end_layout

\begin_layout Plain Layout

		@rect.center = [screen.w / 2, screen.h - @rect.height]
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The Enemies
\end_layout

\begin_layout Standard
At first, this is going to seem very similar to the Asteroids example, because
 our enemies and the Asteroids have a lot in common.
\end_layout

\begin_layout Standard
plane.rb
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class EnemyPlane < SpriteSheetComponent
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def initialize(filename,srcrect)
\end_layout

\begin_layout Plain Layout

		super
\end_layout

\begin_layout Plain Layout

		@speed = 350
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Thrilling! Let's put it on the screen:
\end_layout

\begin_layout Standard
shoot-em.rb
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def main
\end_layout

\begin_layout Plain Layout

	engine = Engine.new
\end_layout

\begin_layout Plain Layout

	engine.screen_width = 1024
\end_layout

\begin_layout Plain Layout

	engine.screen_height = 768
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	engine.screen
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	src = Rect.new(4,4,32,32)	
\end_layout

\begin_layout Plain Layout

	player = PlayerPlane.new("1945.bmp",src)
\end_layout

\begin_layout Plain Layout

	player.colorkey = [0, 67,171]
\end_layout

\begin_layout Plain Layout

	engine.components << player
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	src = Rect.new(499,4,98,98)
\end_layout

\begin_layout Plain Layout

	baddie = EnemyPlane.new("1945.bmp",src)
\end_layout

\begin_layout Plain Layout

	baddie.colorkey = [0, 67, 171]
\end_layout

\begin_layout Plain Layout

	engine.components << baddie
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	engine.run
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Even more thrilling! Running this shows us two sprites; one under your control
 and one that's your sworn enemy.
\end_layout

\begin_layout Subsubsection
Pick a spot and move to it
\end_layout

\begin_layout Standard
The enemy's pretty darn boring at the moment.
 We need a way to move it around on the screen, but here's a spot where
 we want to differ from Asteroids.
 Rather than picking a direction and moving in it (and never deviating)
 we'd like to have the enemies zip around the screen and turn on a dime.
 The usual InertialComponent isn't going to work for those purposes.
\end_layout

\begin_layout Standard
Instead, we'll take a page from Pong - we'll have a target spot and move
 to meet it.
 Add this function to the EnemyPlane:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		if @waypoint == nil || close_to_waypoint?
\end_layout

\begin_layout Plain Layout

			pick_waypoint
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		dx = @waypoint[0] - @rect.x
\end_layout

\begin_layout Plain Layout

		dy = @waypoint[1] - @rect.y
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		@rect.x += dx * delay * @speed
\end_layout

\begin_layout Plain Layout

		@rect.y += dy * delay * @speed
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is pretty simple.
 First we see if the waypoint hasn't been set
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In the full code listing for plane.rb, we explicitly set @waypoint to nil.
 You don't need to make that change here unless you especially want to;
 it'll be nil by default.
\end_layout

\end_inset

 or check to see if the ship's close to its waypoint.
 If so, we pick a new one.
 After that, we move the plane closer to its chosen waypoint.
\end_layout

\begin_layout Standard
If I hadn't moved a ton of functionality into other functions, we could
 run it right now! Since I'm impatient, let's implement some of that functionali
ty.
 Add this to EnemyPlane:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	def close_to_waypoint?
\end_layout

\begin_layout Plain Layout

		if @waypoint
\end_layout

\begin_layout Plain Layout

			dx = (@waypoint[0] - @rect.x).sign
\end_layout

\begin_layout Plain Layout

			dy = (@waypoint[1] - @rect.y).sign
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			if (dx+dy) < @rect.w / 2
\end_layout

\begin_layout Plain Layout

				return true
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		return false
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def pick_waypoint
\end_layout

\begin_layout Plain Layout

		@waypoint = [ 500,500]
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
pick_waypoint is purposely simple right now.
 Obviously we don't want every enemy to do nothing but move to 500,500,
 but it'll make demonstrations easy.
\end_layout

\begin_layout Standard
close_to_waypoint? does exactly what it says; it checks to see the plane's
 close to the waypoint we've picked.
 If you've done much game programming before or have a math background,
 you've likely noticed that we don't actually do a distance check here.
 Instead, we just add the distances on the x and y axis up and see if that's
 less than half our sprite's size.
 This is both easier to understand and faster than doing it the right way.
\end_layout

\begin_layout Standard
The method we're using here is computing the 
\begin_inset Quotes eld
\end_inset

Manhattan Distance
\begin_inset Quotes erd
\end_inset

.
 If you wanted to use the correct distance formula, the code would look
 like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout LyX-Code

if Math.sqrt(dx*dx + dy*dy) < (@rect.w / 2)
\end_layout

\begin_layout LyX-Code

  return true
\end_layout

\begin_layout LyX-Code

end
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Monkeypatching
\end_layout

\begin_layout Standard
You'll get an error if you try to run this; it'll tell you that there's
 no such thing as a 'sign' function for numbers.
 This is annoying; we want to move one way if we're to the left of the spot
 we're going to, and another if we're to the right.
 Similarly, we change the way we move if we're higher or lower.
 A function that would return -1, 0, or 1 depending on the sign of the number
 would be very handy in this case, but there isn't one
\begin_inset Foot
status open

\begin_layout Plain Layout
Well, actually...
 there is.
 You can compare two numbers using the <=> operator (also known as the 'spaceshi
p' operator) and it will return -1, 0, or 1.
 However, this isn't a function you can call on any number, you always have
 to have two numbers with <=>, so our new addition to the Numeric class
 isn't entirely useless.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Yet!
\end_layout

\begin_layout Standard
engine.rb
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Numeric
\end_layout

\begin_layout Plain Layout

	def sign
\end_layout

\begin_layout Plain Layout

		return -1 if self < 0
\end_layout

\begin_layout Plain Layout

		return 1 if self > 0
\end_layout

\begin_layout Plain Layout

		return 0
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you're a ruby expert, you already know what I'm doing here and can safely
 skip the following explanation: When you try to define a class that already
 exists (the 'Numeric' class is the superclass of all numbers), rather than
 replacing the previous definition, whatever functions you add are added
 to the original.
 So once you put this in, every number in your program has access to the
 'sign' function you just made.
\end_layout

\begin_layout Standard
This technique is called 
\begin_inset Quotes eld
\end_inset

Monkey Patching
\begin_inset Quotes erd
\end_inset

 and like the earlier technique of Duck typing, it's very powerful and thus
 easily abused.
 Adding on functionality is usually okay, but be very, very careful if you
 re-write a function that already exists in the class.
 Changing how the '+' operator works for every number in Ruby could get
 very confusing, very quickly!
\end_layout

\begin_layout Standard
Now you can run this and watch as the enemy plane flies from the top left
 of the screen to a spot near the lower right...
 and then bounces around there.
 It's doing that because we never actually tell it to stop moving.
 Later on we'll have it pick a new waypoint and start moving to that - this
 will prevent the bouncing behavior you're seeing now.
\end_layout

\begin_layout Subsubsection
Again, that was 'Enemies', plural
\end_layout

\begin_layout Standard
Much like we did with Asteroids, we're going to create an overall enemy
 creation object to handle all of our enemies.
 Add this to plane.rb:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class AirTrafficControl < BareComponent
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	TIME_BETWEEN_SHIPS = 0.5
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def initialize(engine)
\end_layout

\begin_layout Plain Layout

		super()
\end_layout

\begin_layout Plain Layout

		@engine = engine
\end_layout

\begin_layout Plain Layout

		@wave = 0
\end_layout

\begin_layout Plain Layout

		@active_ships = []
\end_layout

\begin_layout Plain Layout

		@time_to_next_ship = 0
\end_layout

\begin_layout Plain Layout

		begin_wave
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def begin_wave
\end_layout

\begin_layout Plain Layout

		@ships_to_spawn = @wave + 5
\end_layout

\begin_layout Plain Layout

		@wave += 1
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def check_spawn_ship
\end_layout

\begin_layout Plain Layout

		@time_to_next_ship = TIME_BETWEEN_SHIPS
\end_layout

\begin_layout Plain Layout

		if @ships_to_spawn > 0
\end_layout

\begin_layout Plain Layout

			@ships_to_spawn -= 1
\end_layout

\begin_layout Plain Layout

			spawn_ship
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def spawn_ship
\end_layout

\begin_layout Plain Layout

		src = Rect.new(499,4,98,98)
\end_layout

\begin_layout Plain Layout

		baddie = EnemyPlane.new("1945.bmp",src)
\end_layout

\begin_layout Plain Layout

		baddie.colorkey = [0, 67, 171]
\end_layout

\begin_layout Plain Layout

		@engine.components << baddie
\end_layout

\begin_layout Plain Layout

		@active_ships << baddie
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def update(delay)
\end_layout

\begin_layout Plain Layout

		@time_to_next_ship -= delay
\end_layout

\begin_layout Plain Layout

		if @time_to_next_ship <= 0
\end_layout

\begin_layout Plain Layout

			check_spawn_ship
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This isn't really anything we haven't seen before.
 We set up a counter for waves of incoming enemies, and we set up a timer
 to keep track of when we should spawn another plane out of that wave.
 You can run this by changing shoot-em.rb:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def main
\end_layout

\begin_layout Plain Layout

	engine = Engine.new
\end_layout

\begin_layout Plain Layout

	engine.screen_width = 1024
\end_layout

\begin_layout Plain Layout

	engine.screen_height = 768
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	engine.screen
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	src = Rect.new(4,4,32,32)	
\end_layout

\begin_layout Plain Layout

	player = PlayerPlane.new("1945.bmp",src)
\end_layout

\begin_layout Plain Layout

	player.colorkey = [0, 67,171]
\end_layout

\begin_layout Plain Layout

	engine.components << player
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	atc = AirTrafficControl.new(engine)
\end_layout

\begin_layout Plain Layout

	engine.components << atc
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	engine.run
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Running this is only slightly more impressive than the first time around.
 Rather than just having one plane come out and bounce around, now there
 are five - each coming a half-second after the other.
\end_layout

\begin_layout Section
\start_of_appendix
Key Symbol Cheatsheet
\begin_inset CommandInset label
LatexCommand label
name "sec:Key-Symbol-Cheatsheet"

\end_inset


\end_layout

\begin_layout Subsection
Official List
\end_layout

\begin_layout Standard
You can find a list of all key symbols in the Rubygame API documentation
 via the 
\begin_inset Quotes eld
\end_inset

doc/keyboard_symbols.rdoc
\begin_inset Quotes erd
\end_inset

 link or via the Rubygame Wiki at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://rubygame.org/wiki/Keyboard_Symbols
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Guide
\end_layout

\begin_layout Standard
Here are some basic rules for how the key symbols are generated:
\end_layout

\begin_layout Description
Characters
\begin_inset space ~
\end_inset

A-Z: Are simply the symbol versions of themselves.
\end_layout

\begin_layout Description
Numbers: Are prefixed with 
\begin_inset Quotes eld
\end_inset

number_
\begin_inset Quotes erd
\end_inset

 for ordinary numbers, or 
\begin_inset Quotes eld
\end_inset

keypad_
\begin_inset Quotes erd
\end_inset

 for the ones on the numeric keypad.
\end_layout

\begin_layout Description
Function
\begin_inset space ~
\end_inset

Keys: Are prefixed with 
\begin_inset Quotes eld
\end_inset

f
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Category
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Example
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Example
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Characters
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 => :a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 => :x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Numbers
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 => :number_1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 => :keypad_5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function Keys
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F5 => :f5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F12 => :f12
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Cheatsheet.rb
\end_layout

\begin_layout Standard
Here's a program you can use if you want to know what the symbol for any
 given key is:
\end_layout

\begin_layout Standard
cheatsheet.rb
\end_layout

\begin_layout LyX-Code
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout

require 'rubygame'
\end_layout

\begin_layout Plain Layout

include Rubygame
\end_layout

\begin_layout Plain Layout

Rubygame.init()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

screen = Screen.new( [640,480] ) # The size of the window we want
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

queue = EventQueue.new()
\end_layout

\begin_layout Plain Layout

queue.enable_new_style_events()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

finished = false
\end_layout

\begin_layout Plain Layout

while not finished
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	queue.each do | event |
\end_layout

\begin_layout Plain Layout

		case(event)
\end_layout

\begin_layout Plain Layout

		when Events::QuitRequested
\end_layout

\begin_layout Plain Layout

			finished = true
\end_layout

\begin_layout Plain Layout

		when Events::KeyPressed
\end_layout

\begin_layout Plain Layout

			puts "#{event.string} pressed, "+
\end_layout

\begin_layout Plain Layout

				"mods are: #{event.modifiers.join(',')} "+
\end_layout

\begin_layout Plain Layout

				"symbol is: :#{event.key}"
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	Clock.wait(100)
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Rubygame.quit()
\end_layout

\end_inset


\end_layout

\begin_layout Section
Full Code Listings
\end_layout

\begin_layout Section
License
\end_layout

\begin_layout Subsection
Code
\end_layout

\begin_layout Standard
A book full of code isn't of much use if you can't actually use any of the
 code! So in the spirit of letting you get the most out of the examples,
 I'm using the MIT License for the code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Copyright (c) 2011 Roger Ostrander
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Permission is hereby granted, free of charge, to any person obtaining a
 copy
\end_layout

\begin_layout Plain Layout

of this software and associated documentation files (the "Software"), to
 deal
\end_layout

\begin_layout Plain Layout

in the Software without restriction, including without limitation the rights
\end_layout

\begin_layout Plain Layout

to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
\end_layout

\begin_layout Plain Layout

copies of the Software, and to permit persons to whom the Software is
\end_layout

\begin_layout Plain Layout

furnished to do so, subject to the following conditions:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

The above copyright notice and this permission notice shall be included
 in
\end_layout

\begin_layout Plain Layout

all copies or substantial portions of the Software.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 OR
\end_layout

\begin_layout Plain Layout

IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
\end_layout

\begin_layout Plain Layout

FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE
\end_layout

\begin_layout Plain Layout

AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
\end_layout

\begin_layout Plain Layout

LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 FROM,
\end_layout

\begin_layout Plain Layout

OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
\end_layout

\begin_layout Plain Layout

THE SOFTWARE.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Text (and some assets)
\end_layout

\begin_layout Standard
All the text in this book is licensed under the Creative Commons Attribution
 license.
 Any of the image assets that I personally created are also available under
 this same license.
 License text is available at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://creativecommons.org/licenses/by/3.0/
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Things I Didn't Make
\end_layout

\begin_layout Subsubsection
ttf-bitstream-vera-1.10
\end_layout

\begin_layout Standard
The Bitstream Vera font is from the people who made GNOME, and they've made
 it available under a fairly permissive license.
 Consult the COPYRIGHT.TXT file included in the directory for usage details.
\end_layout

\begin_layout Subsubsection
rubygame.png
\end_layout

\begin_layout Standard
This is the Rubygame logo, and it comes with the Rubygame distribution.
 It (as well as a few other sample images that come with the distribution)
 are licensed under the Creative Commons Attribution-ShareAlike 2.5 License,
 viewable at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://creativecommons.org/licenses/by-sa/2.5/ 
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
1945.bmp
\end_layout

\begin_layout Standard
This is from Ari Feldman's Spritelib collection, which is licensed under
 the Common Public License.
 The entire text of the license (as well as Spritelib in its entirety) have
 been included, so consult the license.txt file in the spritelib_gpl directory
 for details.
\end_layout

\end_body
\end_document
